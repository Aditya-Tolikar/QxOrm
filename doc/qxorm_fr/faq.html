<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
  <title>QxOrm - C++ Object Relational Mapping library</title>
  <meta name="generator" content="Amaya, see http://www.w3.org/Amaya/">
  <style type="text/css">
   .comment { color: #008000; font-style: italic; }
   .pre { color: #000099; }
   .string { color: #DF0101; }
   .char { color: #009900; }
   .float { color: #996600; }
   .int { color: #999900; }
   .bool { color: #000000; font-weight: bold; }
   .type { color: #FF6633; }
   .flow { color: #FF0000; }
   .keyword { color: #990000; }
   .operator { color: #663300; font-weight: bold; }
   .operator { color: #663300; font-weight: bold; }
  </style>
</head>
<body>
<table border="0" style="width: 80%" align="center">
  <col><col>
  <tbody>
    <tr>
      <td><a href="./home.html"><img alt="QxOrm"
        src="./resource/logo_qxorm.jpg" width="256" align="left" height="61"
        border="0"></a></td>
      <td><img alt="C++" src="./resource/logo_cpp.jpg" width="50" align="right"
        height="50"></td>
    </tr>
  </tbody>
</table>
<hr style="width: 80%" align="center" size="1" color="#100D5A">
<table border="0" style="width: 80%" align="center">
  <col><col><col><col><col><col>
  <tbody>
    <tr>
      <td align="center"><a href="./home.html"><img alt="Home"
        src="./resource/link_home.jpg" width="120" height="35"
        style="border:1px solid #100D5A; border-color:#100D5A;"></a></td>
      <td align="center"><a href="./download.html"><img alt="Download"
        src="./resource/link_download.jpg" width="120" height="35"
        style="border:1px solid #100D5A; border-color:#100D5A;"></a></td>
      <td align="center"><a href="./quick_sample.html"><img alt="Quick sample"
        src="./resource/link_quick_sample.jpg" width="120" height="35"
        style="border:1px solid #100D5A; border-color:#100D5A;"></a></td>
      <td align="center"><a href="./tutorial.html"><img alt="Tutorial"
        src="./resource/link_tutorial.jpg" width="120" height="35"
        style="border:1px solid #100D5A; border-color:#100D5A;"></a></td>
      <td align="center"><a href="./faq.html"><img alt="Faq"
        src="./resource/link_faq.jpg" width="120" height="35"
        style="border:1px solid #100D5A; border-color:#100D5A;"></a></td>
      <td align="center"><a href="./link.html"><img alt="Link"
        src="./resource/link_link.jpg" width="120" height="35"
        style="border:1px solid #100D5A; border-color:#100D5A;"></a></td>
    </tr>
  </tbody>
</table>
<hr style="width: 80%" align="center" size="1" color="#100D5A">
<table border="0" style="width: 80%" align="center">
  <col><col><col><col><col>
  <tbody><tr>
  <td align="left" valign="top"><font size="2">QxOrm  &gt;&gt;  Faq</font></td>
  <td align="right" valign="top"><font size="2">Version courante : QxOrm 1.1.8 (LGPL) - <a href="../doxygen/index.html" target="_blank">documentation en ligne de la bibliothèque QxOrm</a></font></td>
  <td width="10px"></td>
  <td width="40px" height="30px"><a href="../qxorm_fr/faq.html"><img alt="Version française du site" src="./resource/FR.png" width="40" height="30" border="0"></a></td>
  <td width="40px" height="30px"><a href="../qxorm_en/faq.html"><img alt="Web site english version" src="./resource/GB.png" width="40" height="30" border="0"></a></td>
  </tr></tbody>
</table>
<table border="1" frame="vsides" rules="cols" style="width: 80%" align="center" cellpadding="6" bgcolor="#F2F2F4">
  <col>
  <tbody>
    <tr>
      <td align="justify">
        <table border="0" style="width: 100%" align="center">
          <col><col>
          <tbody>
            <tr>
              <td><ul><li><a href="#faq_10">Qu'est-ce que QxOrm ?</a><br>
                </li><li><a href="#faq_20">Comment contacter QxOrm pour indiquer un bug ou poser une question ?</a><br>
                </li><li><a href="#faq_30">Comment compiler QxOrm ?</a><br>
                </li><li><a href="#faq_40">Quelles sont les bases de données prises en compte par QxOrm ?</a><br>
                </li><li><a href="#faq_50">Pourquoi QxOrm est dépendant de deux bibliothèques : boost et Qt ?</a><br>
                </li><li><a href="#faq_60">Pourquoi QxOrm nécessite un en-tête précompilé (precompiled header) pour pouvoir être utilisé ?</a><br>
                </li><li><a href="#faq_70">Est-il possible d'accélérer les temps de compilation d'un projet ?</a><br>
                </li><li><a href="#faq_75">Quels sont les différents types de <i>serialization</i> disponibles ?</a><br>
                </li><li><a href="#faq_80">Pourquoi QxOrm fournit un nouveau type de container <i>qx::QxCollection&lt;Key, Value&gt;</i> ?</a><br>
                </li><li><a href="#faq_81">Pourquoi QxOrm fournit un nouveau type de pointeur intelligent <i>qx::dao::ptr&lt;T&gt;</i> ?</a><br>
                </li><li><a href="#faq_90">Faut-il utiliser <i>QString</i> ou <i>std::string</i> ?</a><br>
                </li><li><a href="#faq_95">Faut-il utiliser les pointeurs intelligents <i>smart-pointer</i> ?</a><br>
                </li><li><a href="#faq_100">La clé primaire est de type <i>long</i> par défaut. Est-il possible d'utiliser une clé de type <i>QString</i> ou autre ?</a><br>
                </li><li><a href="#faq_101">Comment définir une clé primaire sur plusieurs colonnes (<i>composite key</i>) ?</a><br>
                </li><li><a href="#faq_110">Comment activer/désactiver le module <i>QxMemLeak</i> pour la détection automatique des fuites mémoires ?</a><br>
                </li><li><a href="#faq_120">Comment gérer la notion d'héritage avec la base de données ?</a><br>
                </li><li><a href="#faq_130">Comment utiliser les <i>Trigger</i> ?</a><br>
                </li><li><a href="#faq_140">Comment déclarer une classe abstraite dans le contexte QxOrm ?</a><br>
                </li><li><a href="#faq_150">Comment déclarer une classe définie dans un espace de nom (<i>namespace</i>) dans le contexte QxOrm ?</a><br>
                </li><li><a href="#faq_160">Comment utiliser le mécanisme de suppression logique (<i>soft delete</i>) ?</a><br>
                </li><li><a href="#faq_170">Comment utiliser les sessions (classe <i>qx::QxSession</i>) pour simplifier la gestion des transactions des bases de données (C++ RAII) ?</a><br>
                </li></ul>
              </td>
              <td width="200" align="center" valign="top"><a href="./resource/qt_ambassador_logo.png" target="_blank"><img alt="qt_ambassador" src="./resource/qt_ambassador_logo_150x150.png" width="150" height="150" border="0"></a><br>
                 <b><font size="2">QxOrm library has been accepted into the <a href="http://qt.nokia.com/qt-in-use/ambassadors/qtambassador/" target="_blank">Qt Ambassador Program</a></font></b>
              </td>
            </tr>
          </tbody>
        </table>
      <br>
      <a name="faq_10"><u><b>Qu'est-ce que QxOrm ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
              <b>QxOrm est une bibliothèque C++ open source de gestion de données (Object Relational Mapping, ORM) sous <a href="./resource/license.lgpl.txt" target="_blank">licence LGPL</a>.</b><br>
              <b>QxOrm</b> est développé par Lionel Marty, Ingénieur en développement logiciel depuis 2003.<br>
              <br>
              À partir d'une simple <i>fonction de paramétrage</i> (que l'on peut comparer avec un fichier de mapping XML <i>Hibernate</i>), vous aurez accès aux fonctionnalités suivantes :
              <ul>
                <li><font style="background-color:yellow"><b>persistance</b></font> : communication avec de nombreuses bases de données (avec support des relations <i>1-1</i>, <i>1-n</i>, <i>n-1</i> et <i>n-n</i>) ;
                </li><li><font style="background-color:yellow"><b>sérialisation</b></font> des données (flux binaire et XML) ;
                </li><li>moteur de <font style="background-color:yellow"><b>réflexion</b></font> (ou <font style="background-color:yellow"><b>introspection</b></font>) pour accéder aux classes, attributs et invoquer des méthodes.
                </li>
              </ul>
              <b>QxOrm</b> est dépendant des excellentes bibliothèques <a href="http://www.boost.org/" target="_blank"><b>boost</b></a> (compatible à partir de la version 1.38) et <a href="http://qt.nokia.com/" target="_blank"><b>Qt</b></a> (compatible à partir de la version 4.5.0).<br>
              La bibliothèque <b>QxOrm</b> a été retenue pour faire partie du programme <a href="http://qt.nokia.com/qt-in-use/ambassadors/qtambassador/" target="_blank"><b>Qt Ambassador</b></a>.
              <br><br>
           </td>
         </tr>
       </tbody>
      </table>
      <br>
      <a name="faq_20"><u><b>Comment contacter QxOrm pour indiquer un bug ou poser une question ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           Si vous trouvez un bug ou si vous avez une question concernant le fonctionnement de la bibliothèque <b>QxOrm</b>, 
           vous pouvez envoyer un mail à : <u><i>support@qxorm.com</i></u>.<br>
           <b>QxOrm</b> est également disponible sur le site <a href="http://sourceforge.net/projects/qxorm/files/" target="_blank">SourceForge</a> : plate-forme d'hébergement de projets de développements de logiciels libres.<br>
           Un forum (en anglais) dédié à <b>QxOrm</b> est disponible <a href="http://sourceforge.net/apps/phpbb/qxorm/" target="_blank">en cliquant ici</a>.<br>
           Vous pouvez également retrouver la communauté française de <b>QxOrm</b> sur <a href="http://www.developpez.net/forums/f1563/c-cpp/bibliotheques/qt/outils/bibliotheques/qxorm/" target="_blank">le forum de Developpez.com</a>.
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_30"><u><b>Comment compiler QxOrm ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           <b>QxOrm</b> utilise le processus <i>qmake</i> de la bibliothèque <b>Qt</b> pour générer les <i>makefile</i> et compiler le projet.<br>
           <i>qmake</i> est multiplateforme et fonctionne parfaitement sous Windows, Linux (Unix) et Mac.<br>
           Pour compiler <b>QxOrm</b>, il suffit d'exécuter les commandes suivantes :<br>
           <br>
           <i>qmake</i><br>
           <i>make debug</i><br>
           <i>make release</i><br>
           <br>
           Sous <b>Windows</b>, des fichiers <i>*.vcproj</i> et <i>*.sln</i> sont disponibles pour les éditeurs <b>Visual C++ 2008</b> et <b>Visual C++ 2010</b>.<br>
           Les fichiers <i>*.pro</i> sont lisibles par l'éditeur <b>Qt Creator</b>, et des plugins existent permettant de s'interfacer avec de nombreux éditeurs C++.<br>
           Les fichiers <i>mingw_build_all_debug.bat</i> et <i>mingw_build_all_release.bat</i> présents dans le dossier <i>./tools/</i> permettent de compiler rapidement QxOrm ainsi que tous les tests avec le compilateur <b>MinGW</b> sous Windows.<br>
           Les fichiers <i>gcc_build_all_debug.sh</i> et <i>gcc_build_all_release.sh</i> présents dans le dossier <i>./tools/</i> permettent de compiler rapidement QxOrm ainsi que tous les tests avec <b>GCC</b> sous <b>Linux</b>.<br>
           Enfin, les fichiers <i>osx_build_all_debug.sh</i> et <i>osx_build_all_release.sh</i> présents dans le dossier <i>./tools/</i> permettent de compiler rapidement QxOrm ainsi que tous les tests sous <b>Mac</b> (merci à Dominique Billet pour l'écriture des scripts).<br>
           <br>
           <b>Remarque :</b> suivant l'environnement de développement, il peut être nécessaire de modifier le fichier <u><b>QxOrm.pri</b></u> pour paramétrer la configuration de la bibliothèque <b>boost</b> :<br>
           <br>
           <i>QX_BOOST_INCLUDE_PATH = $$quote(D:/Dvlp/_Libs/Boost/1_42/include)<br>
           QX_BOOST_LIB_PATH = $$quote(D:/Dvlp/_Libs/Boost/1_42/lib_shared)<br>
           QX_BOOST_LIB_SERIALIZATION_DEBUG = "boost_serialization-vc90-mt-gd-1_42"<br>
           QX_BOOST_LIB_SERIALIZATION_RELEASE = "boost_serialization-vc90-mt-1_42"<br></i>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_40"><u><b>Quelles sont les bases de données prises en compte par QxOrm ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           <b>QxOrm</b> utilise le moteur <a href="http://doc.trolltech.com/latest/sql-programming.html" target="_blank"><i>QtSql</i></a> de <b>Qt</b> basé sur un système de plugin.<br>
           Une liste détaillée des bases de données supportées est disponible sur le site de Qt <a href="http://doc.trolltech.com/latest/sql-driver.html" target="_blank">en cliquant ici</a>.<br>
           Le plugin <i>ODBC</i> (<i>QODBC</i>) assure une compatibilité avec de nombreuses bases de données.<br>
           Pour des performances optimales, il est conseillé d'utiliser un plugin spécifique à une base de données :
           <ul><li><i>QMYSQL</i> : MySQL ;
           </li><li><i>QPSQL</i> : PostgreSQL (versions 7.3 and above) ;
           </li><li><i>QOCI</i> : Oracle Call Interface Driver ;
           </li><li><i>QSQLITE</i> : SQLite version 3 ;
           </li><li><i>QDB2</i> : IBM DB2 (version 7.1 and above) ;
           </li><li><i>QIBASE</i> : Borland InterBase ;
           </li><li><i>QTDS</i> : Sybase Adaptive Server.
           </li></ul>
           </td>
         </tr>
       </tbody>
      </table>
      <br>
      <a name="faq_50"><u><b>Pourquoi QxOrm est dépendant de deux bibliothèques : boost et Qt ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           <b>QxOrm</b> utilise de nombreuses fonctionnalités disponibles dans les excellentes bibliothèques <b>boost</b> et <b>Qt</b>.<br>
           De plus, ces deux bibliothèques sont utilisées dans de nombreux projets à la fois professionnels et open-source.<br>
           Il existe un grand nombre de forums, de tutoriaux, et toute une communauté pour répondre à toutes les problématiques que vous pourriez rencontrer.<br>
           L'objectif de <b>QxOrm</b> n'est pas de redévelopper des fonctionnalités qui existent déjà mais de fournir un outil performant d'accès aux bases de données 
           comme il en existe dans d'autres langages (<i>Java</i> avec <i>Hibernate</i>, <i>.Net</i> avec <i>NHibernate</i>, <i>Ruby</i>, <i>Python</i>, etc.).<br><br>
           <table border="0" style="width: 100%" align="center">
             <col>
             <col>
             <tbody>
               <tr>
                 <td valign="middle" width="161" align="center"><a
                   href="http://www.boost.org/" target="_blank"><img alt="boost"
                   src="./resource/logo_boost.jpg" width="161"
                 height="50" border="0"></a></td>
                 <td align="justify"><b>boost</b> : de nombreux modules de la
                   bibliothèque boost font partie de la nouvelle norme C++.<br>
                   C'est une bibliothèque reconnue pour sa qualité, son code 'C++
                   moderne', sa documentation, sa portabilité, etc.<br>
                   QxOrm utilise les fonctionnalités suivantes de boost :
                   <i>smart_pointer, serialization, type_traits,
                   multi_index_container, unordered_container, any, tuple,
                   foreach, function.</i><br>
                   Il est conseillé d'installer et d'utiliser la dernière version
                   de boost disponible à l'adresse suivante : <a
                   href="http://www.boost.org/"
                   target="_blank">http://www.boost.org/</a></td>
               </tr>
             </tbody>
           </table>
           <p></p>
           <table border="0" style="width: 100%" align="center">
             <col>
             <col>
             <tbody>
               <tr>
                 <td valign="middle" width="161" align="center"><a
                   href="http://qt.nokia.com/" target="_blank"><img alt="Qt"
                   src="./resource/logo_qt.jpg" width="42" height="50" border="0"></a></td>
                 <td align="justify"><b>Qt</b> : bibliothèque complète : IHM
                   (<i>QtGui</i>), réseau (<i>QtNetwork</i>), XML (<i>QtXml</i>), base de données
                   (<i>QtSql</i>), etc.<br>
                   La documentation est excellente et le code C++ écrit à partir
                   de cette bibliothèque est à la fois performant et simple de
                   compréhension.<br>
                   Depuis le rachat par Nokia et sa nouvelle licence LGPL, Qt est
                   sans contexte la bibliothèque phare du moment.<br>
                   QxOrm est compatible avec les principaux objets définis par Qt
                   : <i>QObject, QString, QDate, QTime, QDateTime, QList, QHash,
                   QSharedPointer, QScopedPointer, etc.</i><br>
                   Il est conseillé d'installer et d'utiliser la dernière version
                   de Qt disponible à l'adresse suivante : <a
                   href="http://qt.nokia.com/"
                   target="_blank">http://qt.nokia.com/</a></td>
               </tr>
             </tbody>
           </table>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_60"><u><b>Pourquoi QxOrm nécessite un en-tête précompilé (precompiled header) pour pouvoir être utilisé ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           <b>QxOrm</b> utilise les techniques de <b>métaprogrammation C++</b> pour fournir une grande partie de ses fonctionnalités.<br>
           Vous n'avez pas besoin de savoir utiliser la métaprogrammation pour travailler avec la bibliothèque QxOrm.<br>
           En effet, QxOrm se veut simple d'utilisation et un code C++ écrit avec Qt et QxOrm est facile à lire, donc facile à développer et à maintenir.<br><br>
           Cependant, la métaprogrammation est couteuse en temps de compilation.<br>
           En utilisant un fichier <i>precompiled.h</i>, un projet C++ se compilera beaucoup plus vite.<br>
           Un seul fichier d'en-tête est nécessaire pour disposer de l'ensemble des fonctionnalités de QxOrm : le fichier <i>QxOrm.h</i>.
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_70"><u><b>Est-il possible d'accélérer les temps de compilation d'un projet ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           Oui, si la <i>serialization</i> des données au format XML n'est pas utilisée dans le projet, vous pouvez désactiver cette fonctionnalité.<br>
           Les temps de compilation seront alors réduits mais vous n'aurez plus accès au namespace <i>qx::serialization:xml</i>.<br>
           Pour désactiver la <i>serialization XML</i>, il faut ouvrir le fichier <i>QxConfig.h</i> et modifier la constante <b><i>_QX_SERIALIZE_XML</i></b>.<br>
           Une recompilation de la bibliothèque QxOrm est nécessaire pour prendre en compte cette modification.<br><br>
           Une autre possibilité est d'utiliser les classes <i>polymorphiques</i> de la bibliothèque <a href="http://www.boost.org/doc/libs/1_42_0/libs/serialization/doc/index.html" target="_blank"><i>boost::serialization</i></a> (à la place des classes <i>template</i>).<br>
           Cette fonctionnalité réduit les temps de compilation ainsi que la taille de l'éxecutable généré.<br>
           En contre-partie, la vitesse d'exécution du programme sera réduite puisqu'une partie du travail effectué lors de la compilation devra être réalisé à l'exécution de l'application.<br>
           Pour activer cette fonctionnalité dans <b>QxOrm</b>, vous devez modifier la constante <b><i>_QX_SERIALIZE_POLYMORPHIC</i></b> du fichier <i>QxConfig.h</i>.<br>
           <b>Attention</b> : les fonctions de <i>serialization</i> seront alors accessibles depuis les <i>namespace</i> suivants : <i>qx::serialization::polymorphic_binary</i>, <i>qx::serialization::polymorphic_text</i> et <i>qx::serialization::polymorphic_xml</i>.<br>
           Une recompilation de la bibliothèque QxOrm est nécessaire pour prendre en compte cette modification.
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_75"><u><b>Quels sont les différents types de <i>serialization</i> disponibles ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           <b>QxOrm</b> utilise le framework de <i>serialization</i> proposé par la bibliothèque <a href="http://www.boost.org/doc/libs/1_42_0/libs/serialization/doc/index.html" target="_blank">boost</a>.<br>
           Il existe plusieurs types de serialization disponibles : <i>binaire, XML, texte, etc.</i><br>
           Le fichier <i>QxConfig.h</i> permet d'activer et/ou désactiver les différents types de serialization.<br>
           <br>
           Chaque type de serialization possède ses propres caractéristiques :
           <ul>
             <li><b>binary</b> : <i>smallest, fastest, non-portable</i> ;
             </li><li><b>text</b> : <i>larger, slower, portable</i> ;
             </li><li><b>XML</b> : <i>largest, slowest, portable</i>.
             </li>
           </ul>
           <b>Remarque :</b> le type <b>binary</b> n'est pas portable, ce qui signifie que des données ne peuvent pas s'échanger entre un sytème Windows et un système Unix par exemple.<br>
           Si vous devez faire transiter des données sur un réseau à travers plusieurs systèmes d'exploitation, il faut utiliser le type de serialization <b>text</b> ou <b>XML</b>.<br>
           <b>QxOrm</b> propose également une autre solution : le type de serialization <b><a href="http://www.boostpro.com/vault/index.php?directory=serialization" target="_blank">portable_binary</a></b>.<br>
           Le type <b>portable_binary</b> possède les mêmes caractéristiques que le type <b>binary</b> et permet d'échanger des données de manière portable.<br>
           Cependant, ce type de serialization n'est pas proposé officiellement par la bibliothèque <b>boost</b>, il est donc nécessaire de tester avant de l'utiliser dans un logiciel en production.
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_80"><u><b>Pourquoi QxOrm fournit un nouveau type de container <i>qx::QxCollection&lt;Key, Value&gt;</i> ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           Il existe de nombreux <i>container</i> dans les bibliothèques <b>stl</b>, <b>boost</b> et <b>Qt</b>.<br>
           Il est donc légitime de se poser cette question : à quoi sert <i>qx::QxCollection&lt;Key, Value&gt;</i> ?<br>
           <i>qx::QxCollection&lt;Key, Value&gt;</i> est un nouveau <i>container</i> (basé sur l'excellente bibliothèque <a href="http://www.boost.org/doc/libs/1_42_0/libs/multi_index/doc/index.html" target="_blank"><i>boost::multi_index_container</i></a>) qui possède les fonctionnalités suivantes :
           <ul><li>conserve l'ordre d'insertion des éléments dans la liste ;
           </li><li>accès rapide à un élément par son index : équivaut à <i>std::vector&lt;T&gt;</i> ou <i>QList&lt;T&gt;</i> par exemple ;
           </li><li>accès rapide à un élément par une clé (<i>hash-map</i>) : équivaut à <i>QHash&lt;Key, Value&gt;</i> ou <i>boost::unordered_map&lt;Key, Value&gt;</i> par exemple ;
           </li><li>fonctions de tri sur le type <i>Key</i> et sur le type <i>Value</i>.
           </li></ul>
           <b>Remarque :</b>
           <i>qx::QxCollection&lt;Key, Value&gt;</i> est compatible avec la macro <i>foreach</i> fournie par la bibliothèque <b>Qt</b> ainsi que par la macro <a href="http://www.boost.org/doc/libs/1_42_0/doc/html/foreach.html" target="_blank"><i>BOOST_FOREACH</i></a> fournie par la bibliothèque <b>boost</b>.<br>
           Cependant, chaque élément renvoyé par ces deux macros correspond à un objet de type <i>std::pair&lt;Key, Value&gt;</i>.<br>
           Pour obtenir un résultat 'plus naturel' et plus lisible, il est conseillé d'utiliser la macro <i>_foreach</i> : cette macro utilise <i>BOOST_FOREACH</i> pour tous les <i>container</i> sauf pour <i>qx::QxCollection&lt;Key, Value&gt;</i>.<br>
           Dans ce cas, l'élément renvoyé correspond au type <i>Value</i> (voir par la suite l'exemple d'utilisation).<br>
           La macro <i>_foreach</i> est donc compatible avec tous les <i>container</i> (<b>stl</b>, <b>Qt</b>, <b>boost</b>, etc.) puisqu'elle utilise la macro <i>BOOST_FOREACH</i>.<br><br>
           <b>Autre Remarque :</b>
           <i>qx::QxCollection&lt;Key, Value&gt;</i> est particulièrement adapté pour recevoir des données issues d'une base de données.<br>
           En effet, ces données peuvent être triées (en utilisant <i>ORDER BY</i> dans une requête SQL par exemple), il est donc important de conserver l'ordre d'insertion des éléments dans la liste.<br>
           De plus, chaque donnée issue d'une base de données possède un identifiant unique. Il est donc intéressant de pouvoir accéder à un élément en fonction de cet identifiant unique de manière extrèmement rapide (<i>hash-map</i>).<br><br>
           <b>Exemple d'utilisation de la collection <i>qx::QxCollection&lt;Key, Value&gt;</i> :</b><br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">/* définition d'une classe drug avec 3 propriétés : 'code', 'name', 'description' */</span><span class="keyword">
class</span> drug<span class="operator"> {</span><span class="keyword"> public</span><span class="operator">:</span> QString code<span class="operator">;</span> QString name<span class="operator">;</span> QString desc<span class="operator">; };</span><span class="comment">

/* pointeur intelligent associé à la classe drug */</span><span class="keyword">
typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>drug<span class="operator">&gt;</span> drug_ptr<span class="operator">;</span><span class="comment">

/* collection de drugs (accès rapide à un élément de la collection par la propriété 'code') */</span>
qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span>QString<span class="operator">,</span> drug_ptr<span class="operator">&gt;</span> lstDrugs<span class="operator">;</span><span class="comment">

/* création de 3 nouveaux drugs */</span>
drug_ptr d1<span class="operator">;</span> d1<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span> d1<span class="operator">-&gt;</span>code<span class="operator"> =</span><span class="string"> "code1"</span><span class="operator">;</span> d1<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name1"</span><span class="operator">;</span> d1<span class="operator">-&gt;</span>desc<span class="operator"> =</span><span class="string"> "desc1"</span><span class="operator">;</span>
drug_ptr d2<span class="operator">;</span> d2<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span> d2<span class="operator">-&gt;</span>code<span class="operator"> =</span><span class="string"> "code2"</span><span class="operator">;</span> d2<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name2"</span><span class="operator">;</span> d2<span class="operator">-&gt;</span>desc<span class="operator"> =</span><span class="string"> "desc2"</span><span class="operator">;</span>
drug_ptr d3<span class="operator">;</span> d3<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span> d3<span class="operator">-&gt;</span>code<span class="operator"> =</span><span class="string"> "code3"</span><span class="operator">;</span> d3<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name3"</span><span class="operator">;</span> d3<span class="operator">-&gt;</span>desc<span class="operator"> =</span><span class="string"> "desc3"</span><span class="operator">;</span><span class="comment">

/* insertion des 3 drugs dans la collection */</span>
lstDrugs<span class="operator">.</span>insert<span class="operator">(</span>d1<span class="operator">-&gt;</span>code<span class="operator">,</span> d1<span class="operator">);</span>
lstDrugs<span class="operator">.</span>insert<span class="operator">(</span>d2<span class="operator">-&gt;</span>code<span class="operator">,</span> d2<span class="operator">);</span>
lstDrugs<span class="operator">.</span>insert<span class="operator">(</span>d3<span class="operator">-&gt;</span>code<span class="operator">,</span> d3<span class="operator">);</span><span class="comment">

/* parcours la collection en utilisant le mot-clé '_foreach' */</span>
_foreach<span class="operator">(</span>drug_ptr p<span class="operator">,</span> lstDrugs<span class="operator">)
{</span> qDebug<span class="operator">() &lt;&lt;</span> qPrintable<span class="operator">(</span>p<span class="operator">-&gt;</span>name<span class="operator">) &lt;&lt;</span><span class="string"> " "</span><span class="operator"> &lt;&lt;</span> qPrintable<span class="operator">(</span>p<span class="operator">-&gt;</span>desc<span class="operator">); }</span><span class="comment">

/* parcours la collection en utilisant une boucle 'for' */</span><span class="flow">
for</span><span class="operator"> (</span><span class="type">long</span> l<span class="operator"> =</span><span class="int"> 0</span><span class="operator">;</span> l<span class="operator"> &lt;</span> lstDrugs<span class="operator">.</span>count<span class="operator">(); ++</span>l<span class="operator">)
{</span>
   drug_ptr p<span class="operator"> =</span> lstDrugs<span class="operator">.</span>getByIndex<span class="operator">(</span>l<span class="operator">);</span>
   QString code<span class="operator"> =</span> lstDrugs<span class="operator">.</span>getKeyByIndex<span class="operator">(</span>l<span class="operator">);</span>
   qDebug<span class="operator">() &lt;&lt;</span> qPrintable<span class="operator">(</span>p<span class="operator">-&gt;</span>name<span class="operator">) &lt;&lt;</span><span class="string"> " "</span><span class="operator"> &lt;&lt;</span> qPrintable<span class="operator">(</span>p<span class="operator">-&gt;</span>desc<span class="operator">);
}</span><span class="comment">

/* parcours la collection en utilisant le style Java avec 'QxCollectionIterator' */</span>
qx<span class="operator">::</span>QxCollectionIterator<span class="operator">&lt;</span>QString<span class="operator">,</span> drug_ptr<span class="operator">&gt;</span> itr<span class="operator">(</span>lstDrugs<span class="operator">);</span><span class="flow">
while</span><span class="operator"> (</span>itr<span class="operator">.</span>next<span class="operator">())
{</span>
   QString code<span class="operator"> =</span> itr<span class="operator">.</span>key<span class="operator">();</span>
   qDebug<span class="operator">() &lt;&lt;</span> qPrintable<span class="operator">(</span>itr<span class="operator">.</span>value<span class="operator">()-&gt;</span>name<span class="operator">) &lt;&lt;</span><span class="string"> " "</span><span class="operator"> &lt;&lt;</span> qPrintable<span class="operator">(</span>itr<span class="operator">.</span>value<span class="operator">()-&gt;</span>desc<span class="operator">);
}</span><span class="comment">

/* effectue un tri croissant par clé (propriété 'code') et décroissant par valeur */</span>
lstDrugs<span class="operator">.</span>sortByKey<span class="operator">(</span><span class="bool">true</span><span class="operator">);</span>
lstDrugs<span class="operator">.</span>sortByValue<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="comment">

/* accès rapide à un drug par son 'code' */</span>
drug_ptr p<span class="operator"> =</span> lstDrugs<span class="operator">.</span>getByKey<span class="operator">(</span><span class="string">"code2"</span><span class="operator">);</span><span class="comment">

/* accès rapide à un drug par son index (position) dans la collection */</span>
drug_ptr p<span class="operator"> =</span> lstDrugs<span class="operator">.</span>getByIndex<span class="operator">(</span><span class="int">2</span><span class="operator">);</span><span class="comment">

/* teste si un drug existe dans la collection et si la liste est vide */</span><span class="type">
bool</span> bExist<span class="operator"> =</span> lstDrugs<span class="operator">.</span>exist<span class="operator">(</span><span class="string">"code3"</span><span class="operator">);</span><span class="type">
bool</span> bEmpty<span class="operator"> =</span> lstDrugs<span class="operator">.</span>empty<span class="operator">();</span><span class="comment">

/* supprime de la collection le 2ème élément */</span>
lstDrugs<span class="operator">.</span>removeByIndex<span class="operator">(</span><span class="int">2</span><span class="operator">);</span><span class="comment">

/* supprime de la collection l'élément avec le code 'code3' */</span>
lstDrugs<span class="operator">.</span>removeByKey<span class="operator">(</span><span class="string">"code3"</span><span class="operator">);</span><span class="comment">

/* efface tous les éléments de la collection */</span>
lstDrugs<span class="operator">.</span>clear<span class="operator">();</span></pre>
           </td></tr></tbody></table>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_81"><u><b>Pourquoi QxOrm fournit un nouveau type de pointeur intelligent <i>qx::dao::ptr&lt;T&gt;</i> ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           <b>QxOrm</b> est compatible avec les pointeurs intelligents des bibliothèques <b>boost</b> et <b>Qt</b>.<br>
           Le pointeur intelligent développé par <b>QxOrm</b> est basé sur <i>QSharedPointer</i> et apporte de nouvelles fonctionnalités s'il est utilisé avec les fonctions '<i>qx::dao::...</i>'.<br>
           <i>qx::dao::ptr&lt;T&gt;</i> conserve automatiquement les valeurs issues de la base de données.<br>
           Il est ainsi possible de vérifier à tout moment si une instance d'objet a subi des modifications grâce à la méthode '<i>isDirty()</i>' : cette méthode peut renvoyer la liste de toutes les propriétés ayant été modifiées.<br>
           <i>qx::dao::ptr&lt;T&gt;</i> peut également être utilisé par la fonction '<i>qx::dao::update_optimized()</i>' pour mettre à jour en base de données uniquement les champs modifiés.<br>
           <i>qx::dao::ptr&lt;T&gt;</i> peut être utilisé avec un objet simple ou bien avec la plupart des containers : <i>stl</i>, <i>boost</i>, <i>Qt</i> et <i>qx::QxCollection&lt;Key, Value&gt;</i>.<br>
           <br>
           <b>Exemple d'utilisation du pointeur intelligent <i>qx::dao::ptr&lt;T&gt;</i> :</b><br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// exemple d'utilisation de la méthode 'isDirty()'
</span>qx<span class="operator">::</span>dao<span class="operator">::</span>ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_isdirty<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;(</span><span class="keyword">new</span> blog<span class="operator">());</span>
blog_isdirty<span class="operator">-&gt;</span>m_id<span class="operator"> =</span> blog_1<span class="operator">-&gt;</span>m_id<span class="operator">;</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id<span class="operator">(</span>blog_isdirty<span class="operator">);</span>
qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">() &amp;&amp; !</span> blog_isdirty<span class="operator">.</span>isDirty<span class="operator">());</span>

blog_isdirty<span class="operator">-&gt;</span>m_text<span class="operator"> =</span><span class="string"> "blog property 'text' modified =&gt; blog is dirty !!!"</span><span class="operator">;</span>
QStringList lstDiff<span class="operator">;</span><span class="type"> bool</span> bDirty<span class="operator"> =</span> blog_isdirty<span class="operator">.</span>isDirty<span class="operator">(</span>lstDiff<span class="operator">);</span>
qAssert<span class="operator">(</span>bDirty<span class="operator"> &amp;&amp; (</span>lstDiff<span class="operator">.</span>count<span class="operator">() ==</span><span class="int"> 1</span><span class="operator">) &amp;&amp; (</span>lstDiff<span class="operator">.</span>at<span class="operator">(</span><span class="int">0</span><span class="operator">) ==</span><span class="string"> "blog_text"</span><span class="operator">));</span><span class="flow">
if</span><span class="operator"> (</span>bDirty<span class="operator">) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] test dirty 1 : blog is dirty =&gt; '%s'"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>lstDiff<span class="operator">.</span>join<span class="operator">(</span><span class="string">"|"</span><span class="operator">))); }</span><span class="comment">

// met à jour uniquement la propriété 'm_text' de l'instance 'blog_isdirty'
</span>daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>update_optimized<span class="operator">(</span>blog_isdirty<span class="operator">);</span>
qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">() &amp;&amp; !</span> blog_isdirty<span class="operator">.</span>isDirty<span class="operator">());</span>
qx<span class="operator">::</span>dump<span class="operator">(</span>blog_isdirty<span class="operator">);</span><span class="comment">

// exemple d'utilisation de la méthode 'isDirty()' avec une liste d'objets
</span><span class="keyword">typedef</span> qx<span class="operator">::</span>dao<span class="operator">::</span>ptr<span class="operator">&lt;</span> QList<span class="operator">&lt;</span>author_ptr<span class="operator">&gt; &gt;</span> type_lst_author_test_is_dirty<span class="operator">;</span>

type_lst_author_test_is_dirty container_isdirty<span class="operator"> =</span> type_lst_author_test_is_dirty<span class="operator">(</span><span class="keyword">new</span> QList<span class="operator">&lt;</span>author_ptr<span class="operator">&gt;());</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_all<span class="operator">(</span>container_isdirty<span class="operator">);</span>
qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">() &amp;&amp; !</span> container_isdirty<span class="operator">.</span>isDirty<span class="operator">() &amp;&amp; (</span>container_isdirty<span class="operator">-&gt;</span>count<span class="operator">() ==</span><span class="int"> 3</span><span class="operator">));</span>

author_ptr author_ptr_dirty<span class="operator"> =</span> container_isdirty<span class="operator">-&gt;</span>at<span class="operator">(</span><span class="int">1</span><span class="operator">);</span>
author_ptr_dirty<span class="operator">-&gt;</span>m_name<span class="operator"> =</span><span class="string"> "author name modified at index 1 =&gt; container is dirty !!!"</span><span class="operator">;</span>
bDirty<span class="operator"> =</span> container_isdirty<span class="operator">.</span>isDirty<span class="operator">(</span>lstDiff<span class="operator">);</span>
qAssert<span class="operator">(</span>bDirty<span class="operator"> &amp;&amp; (</span>lstDiff<span class="operator">.</span>count<span class="operator">() ==</span><span class="int"> 1</span><span class="operator">));</span><span class="flow">
if</span><span class="operator"> (</span>bDirty<span class="operator">) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] test dirty 2 : container is dirty =&gt; '%s'"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>lstDiff<span class="operator">.</span>join<span class="operator">(</span><span class="string">"|"</span><span class="operator">))); }</span>

author_ptr_dirty<span class="operator"> =</span> container_isdirty<span class="operator">-&gt;</span>at<span class="operator">(</span><span class="int">2</span><span class="operator">);</span>
author_ptr_dirty<span class="operator">-&gt;</span>m_birthdate<span class="operator"> =</span> QDate<span class="operator">(</span><span class="int">1998</span><span class="operator">,</span><span class="int"> 03</span><span class="operator">,</span><span class="int"> 06</span><span class="operator">);</span>
bDirty<span class="operator"> =</span> container_isdirty<span class="operator">.</span>isDirty<span class="operator">(</span>lstDiff<span class="operator">);</span>
qAssert<span class="operator">(</span>bDirty<span class="operator"> &amp;&amp; (</span>lstDiff<span class="operator">.</span>count<span class="operator">() ==</span><span class="int"> 2</span><span class="operator">));</span><span class="flow">
if</span><span class="operator"> (</span>bDirty<span class="operator">) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] test dirty 3 : container is dirty =&gt; '%s'"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>lstDiff<span class="operator">.</span>join<span class="operator">(</span><span class="string">"|"</span><span class="operator">))); }</span><span class="comment">

// met à jour la propriété 'm_name' en position 1, la propriété 'm_birthdate' en position 2 et ne change rien en position 0
</span>daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>update_optimized<span class="operator">(</span>container_isdirty<span class="operator">);</span>
qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">() &amp;&amp; !</span> container_isdirty<span class="operator">.</span>isDirty<span class="operator">());</span>
qx<span class="operator">::</span>dump<span class="operator">(</span>container_isdirty<span class="operator">);</span><span class="comment">

// récupère uniquement la propriété 'm_dt_creation' du blog
</span>QStringList lstColumns<span class="operator"> =</span> QStringList<span class="operator">() &lt;&lt;</span><span class="string"> "date_creation"</span><span class="operator">;</span>
list_blog lst_blog_with_only_date_creation<span class="operator">;</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_all<span class="operator">(</span>lst_blog_with_only_date_creation<span class="operator">,</span> NULL<span class="operator">,</span> lstColumns<span class="operator">);</span>
qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">() &amp;&amp; (</span>lst_blog_with_only_date_creation<span class="operator">.</span>size<span class="operator">() &gt;</span><span class="int"> 0</span><span class="operator">));</span><span class="flow">

if</span><span class="operator"> ((</span>lst_blog_with_only_date_creation<span class="operator">.</span>size<span class="operator">() &gt;</span><span class="int"> 0</span><span class="operator">) &amp;&amp; (</span>lst_blog_with_only_date_creation<span class="operator">[</span><span class="int">0</span><span class="operator">] !=</span> NULL<span class="operator">))
{</span> qAssert<span class="operator">(</span>lst_blog_with_only_date_creation<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_text<span class="operator">.</span>isEmpty<span class="operator">()); }</span>

qx<span class="operator">::</span>dump<span class="operator">(</span>lst_blog_with_only_date_creation<span class="operator">);</span></pre>
           </td></tr></tbody></table>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_90"><u><b>Faut-il utiliser <i>QString</i> ou <i>std::string</i> ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           <b>QxOrm</b> conseille d'utiliser la classe <a href="http://doc.trolltech.com/latest/qstring.html" target="_blank"><i>QString</i></a> pour la gestion des chaînes de caractères.<br>
           Même si <b>boost</b> fournit de nombreuses fonctionnalités avec son module <a href="http://www.boost.org/doc/libs/1_42_0/doc/html/string_algo.html" target="_blank"><i>boost::string_algo</i></a>, 
           la classe <i>QString</i> est plus simple à utiliser et surtout prend en charge automatiquement les différents formats : <i>Ascii, Utf8, Utf16, etc.</i><br>
           Cependant, <b>QxOrm</b> est compatible avec <i>std::string</i> et <i>std::wstring</i> si vous préférez utiliser ce type de chaîne de caractères.
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_95"><u><b>Faut-il utiliser les pointeurs intelligents <i>smart-pointer</i> ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           <b>QxOrm</b> conseille fortement d'utiliser les pointeurs intelligents de <b>boost</b> ou <b>Qt</b>.<br>
           Le langage C++ ne possède pas de <i>Garbage Collector</i> comme <i>Java</i> ou <i>C#</i> par exemple.<br>
           L'utilisation des <i>smart-pointer</i> simplifie énormément la gestion de la mémoire en C++.<br>
           L'idéal dans un programme C++ est de n'avoir aucun appel à <i>delete</i> ou <i>delete[]</i>.<br>
           De plus, les <i>smart-pointer</i> font partie de la nouvelle norme C++ : <b>C++1x</b>.<br>
           Il est donc essentiel aujourd'hui de connaître les classes suivantes :
           <ul><li><a href="http://www.boost.org/doc/libs/1_42_0/libs/smart_ptr/smart_ptr.htm" target="_blank"><i>shared_ptr</i>, <i>scoped_ptr</i> et <i>weak_ptr</i></a> pour les pointeurs intelligents de la bibliothèque <b>boost</b> ;
           </li><li><a href="http://qt.nokia.com/doc/latest/qsharedpointer.html" target="_blank"><i>QSharedPointer</i>, <i>QScopedPointer</i> et <i>QWeakPointer</i></a> pour les pointeurs intelligents de la bibliothèque <b>Qt</b>.
           </li></ul>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_100"><u><b>La clé primaire est de type <i>long</i> par défaut. Est-il possible d'utiliser une clé de type <i>QString</i> ou autre ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           Il est possible de définir un identifiant unique de type <i>QString</i> ou autre avec la bibliothèque <b>QxOrm</b>.<br>
           Par défaut, l'identifiant unique est de type <i>long</i>.<br>
           Pour indiquer qu'une classe a un identifiant unique de type <i>QString</i> ou autre, il faut spécialiser le template <i>qx::trait::get_primary_key</i>.<br>
           Pour simplifier, vous pouvez utiliser la macro : <b><i>QX_REGISTER_PRIMARY_KEY(myClass, QString)</i></b>.<br>
           <br>
           <b>Attention :</b> la macro <b><i>QX_REGISTER_PRIMARY_KEY</i></b> doit être utilisée avant la macro <b><i>QX_REGISTER_HPP_...</i></b> dans la définition de la classe, sinon une erreur de compilation se produit.
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_101"><u><b>Comment définir une clé primaire sur plusieurs colonnes (<i>composite key</i>) ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           <b>QxOrm</b> supporte la notion de '<i>multi-columns primary key</i>'.<br>
           L'identifiant de la classe doit être du type suivant :
           <ul>
           <li><i>QPair</i> ou <i>std::pair</i> pour définir deux colonnes ;
           </li><li><i>boost::tuple</i> pour définir de deux à neuf colonnes.
           </li></ul>
           Il est nécessaire d'utiliser la macro <b><i>QX_REGISTER_PRIMARY_KEY()</i></b> pour spécialiser le template et ainsi définir le type d'identifiant sur plusieurs colonnes.<br>
           La liste des noms des colonnes doit être de la forme suivante : '<i>column1|column2|column3|etc.</i>'.<br>
           <br>
           <b>Exemple d'utilisation</b> avec la classe '<i>author</i>' du projet '<i>qxBlogCompositeKey</i>', cette classe possède un identifiant sur trois colonnes :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _QX_BLOG_AUTHOR_H_
#define _QX_BLOG_AUTHOR_H_
</span><span class="keyword">
class</span> blog<span class="operator">;</span><span class="keyword">

class</span> QX_BLOG_DLL_EXPORT author<span class="operator">
{</span>

   QX_REGISTER_FRIEND_CLASS<span class="operator">(</span>author<span class="operator">)</span><span class="keyword">

public</span><span class="operator">:</span><span class="comment">

// -- clé composée (clé primaire définie sur plusieurs colonnes dans la base de données)
</span><span class="keyword">   typedef</span> boost<span class="operator">::</span>tuple<span class="operator">&lt;</span>QString<span class="operator">,</span><span class="type"> long</span><span class="operator">,</span> QString<span class="operator">&gt;</span> type_composite_key<span class="operator">;</span><span class="keyword">
   static</span> QString str_composite_key<span class="operator">() {</span><span class="flow"> return</span><span class="string"> "author_id_0|author_id_1|author_id_2"</span><span class="operator">; }</span><span class="comment">

// -- typedef
</span><span class="keyword">   typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_ptr<span class="operator">;</span><span class="keyword">
   typedef</span> std<span class="operator">::</span>vector<span class="operator">&lt;</span>blog_ptr<span class="operator">&gt;</span> list_blog<span class="operator">;</span><span class="comment">

// -- enum
</span><span class="keyword">   enum</span> enum_sex<span class="operator"> {</span> male<span class="operator">,</span> female<span class="operator">,</span> unknown<span class="operator"> };</span><span class="comment">

// -- propriétés
</span>   type_composite_key   m_id<span class="operator">;</span>
   QString              m_name<span class="operator">;</span>
   QDate                m_birthdate<span class="operator">;</span>
   enum_sex             m_sex<span class="operator">;</span>
   list_blog            m_blogX<span class="operator">;</span><span class="comment">

// -- constructeur, destructeur virtuel
</span>   author<span class="operator">() :</span> m_id<span class="operator">(</span><span class="string">""</span><span class="operator">,</span><span class="int"> 0</span><span class="operator">,</span><span class="string"> ""</span><span class="operator">),</span> m_sex<span class="operator">(</span>unknown<span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>author<span class="operator">() { ; }</span><span class="comment">

// -- méthodes
</span><span class="type">   int</span> age<span class="operator">()</span><span class="keyword"> const</span><span class="operator">;</span><span class="comment">

// -- méthodes d'accès à la clé composée
</span>   type_composite_key getId<span class="operator">()</span><span class="keyword"> const</span><span class="operator">    {</span><span class="flow"> return</span> m_id<span class="operator">; }</span>
   QString getId_0<span class="operator">()</span><span class="keyword"> const</span><span class="operator">             {</span><span class="flow"> return</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">0</span><span class="operator">&gt;(</span>m_id<span class="operator">); }</span><span class="type">
   long</span> getId_1<span class="operator">()</span><span class="keyword"> const</span><span class="operator">                {</span><span class="flow"> return</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">1</span><span class="operator">&gt;(</span>m_id<span class="operator">); }</span>
   QString getId_2<span class="operator">()</span><span class="keyword"> const</span><span class="operator">             {</span><span class="flow"> return</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">2</span><span class="operator">&gt;(</span>m_id<span class="operator">); }</span><span class="comment">

// -- méthodes de modification de la clé composée
</span><span class="type">   void</span> setId_0<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> s<span class="operator">)     {</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">0</span><span class="operator">&gt;(</span>m_id<span class="operator">) =</span> s<span class="operator">; }</span><span class="type">
   void</span> setId_1<span class="operator">(</span><span class="type">long</span> l<span class="operator">)                {</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">1</span><span class="operator">&gt;(</span>m_id<span class="operator">) =</span> l<span class="operator">; }</span><span class="type">
   void</span> setId_2<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> s<span class="operator">)     {</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">2</span><span class="operator">&gt;(</span>m_id<span class="operator">) =</span> s<span class="operator">; }

};</span>

QX_REGISTER_PRIMARY_KEY<span class="operator">(</span>author<span class="operator">,</span> author<span class="operator">::</span>type_composite_key<span class="operator">)</span>
QX_REGISTER_HPP_QX_BLOG<span class="operator">(</span>author<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="keyword">

typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>author<span class="operator">&gt;</span> author_ptr<span class="operator">;</span><span class="keyword">
typedef</span> qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span>author<span class="operator">::</span>type_composite_key<span class="operator">,</span> author_ptr<span class="operator">&gt;</span> list_author<span class="operator">;</span><span class="pre">

#endif // _QX_BLOG_AUTHOR_H_
</span></pre>
           </td></tr></tbody></table>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#include "../include/precompiled.h"
#include "../include/author.h"
#include "../include/blog.h"
#include &lt;QxMemLeak.h&gt;
</span>
QX_REGISTER_CPP_QX_BLOG<span class="operator">(</span>author<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>author<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   t<span class="operator">.</span>id<span class="operator">(&amp;</span> author<span class="operator">::</span>m_id<span class="operator">,</span> author<span class="operator">::</span>str_composite_key<span class="operator">());</span>

   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_name<span class="operator">,</span><span class="string"> "name"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_birthdate<span class="operator">,</span><span class="string"> "birthdate"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_sex<span class="operator">,</span><span class="string"> "sex"</span><span class="operator">);</span>

   t<span class="operator">.</span>relationOneToMany<span class="operator">(&amp;</span> author<span class="operator">::</span>m_blogX<span class="operator">,</span> blog<span class="operator">::</span>str_composite_key<span class="operator">(),</span> author<span class="operator">::</span>str_composite_key<span class="operator">());</span>

   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;(&amp;</span> author<span class="operator">::</span>age<span class="operator">,</span><span class="string"> "age"</span><span class="operator">);
}}</span><span class="type">

int</span> author<span class="operator">::</span>age<span class="operator">()</span><span class="keyword"> const</span><span class="operator">
{</span><span class="flow">
   if</span><span class="operator"> (!</span> m_birthdate<span class="operator">.</span>isValid<span class="operator">()) {</span><span class="flow"> return</span><span class="operator"> -</span><span class="int">1</span><span class="operator">; }</span><span class="flow">
   return</span><span class="operator"> (</span>QDate<span class="operator">::</span>currentDate<span class="operator">().</span>year<span class="operator">() -</span> m_birthdate<span class="operator">.</span>year<span class="operator">());
}</span>
</pre>
           </td></tr></tbody></table>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_110"><u><b>Comment activer/désactiver le module <i>QxMemLeak</i> pour la détection automatique des fuites mémoires ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           Le module <i>QxMemLeak</i> permet une détection rapide des fuites
           mémoire en mode <i>Debug</i> une fois l'exécution du programme terminée
           (avec indication du fichier et de la ligne =&gt; style MFC de
           Microsoft).<br>
           Ce module a été développé par <a href="http://wyw.dcweb.cn/leakage.htm" target="_blank">Wu Yongwei</a> et a subi
           quelques modifications pour être intégré dans <b>QxOrm</b>.<br>
           Si un autre outil est déjà utilisé (<i>Valgrind</i> par exemple),
           cette fonctionnalité ne doit pas être activée.<br>
           Pour activer/désactiver le module <i>QxMemLeak</i>, il suffit de modifier la constante 
           <b><i>_QX_USE_MEM_LEAK_DETECTION</i></b> définie dans le fichier <i>QxConfig.h</i>.<br>
           Une recompilation de la bibliothèque QxOrm est nécessaire pour prendre en compte cette modification. 
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_120"><u><b>Comment gérer la notion d'héritage avec la base de données ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           On retrouve généralement dans les différents outils de type <i>ORM</i> trois différentes stratégies pour gérer la notion d'héritage avec la base de données :
           <ul>
           <li><i>Single Table Inheritance</i> ;
           </li><li><i>Class Table Inheritance</i> ;
           </li><li><i>Concrete Table Inheritance</i>.
           </li></ul>
           <b>QxOrm</b> utilise par défaut la stratégie <i>Concrete Table Inheritance</i> (les autres stratégies ne sont pas fonctionnelles à l'heure actuelle).<br>
           De nombreux tutoriaux et forums sont disponibles sur internet pour plus de détails sur cette notion d'héritage.<br>
           Un exemple d'utilisation avec une classe de base se trouve dans le dossier <i>./test/qxDllSample/dll2/</i> avec la classe <i>BaseClassTrigger</i>.
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_130"><u><b>Comment utiliser les <i>Trigger</i> ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           Les <i>Trigger</i> de <b>QxOrm</b> permettent d'effectuer divers traitements avant et/ou après une insertion, une mise à jour ou bien une suppression dans la base de données.<br>
           Un exemple d'utilisation se trouve dans le dossier <i>./test/qxDllSample/dll2/</i> avec la classe <i>BaseClassTrigger</i>.<br>
           Cette classe contient cinq propriétés : <i>m_id</i>, <i>m_dateCreation</i>, <i>m_dateModification</i>, <i>m_userCreation</i> et <i>m_userModification</i>.<br>
           Ces propriétés se mettront à jour automatiquement pour chaque classe héritant de <i>BaseClassTrigger</i> (cf. les classes <i>Foo</i> et <i>Bar</i> du même projet).<br>
           Il est nécessaire de spécialiser le template '<i>QxDao_Trigger</i>' pour profiter de cette fonctionnalité.<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _QX_BASE_CLASS_TRIGGER_H_
#define _QX_BASE_CLASS_TRIGGER_H_
</span><span class="keyword">
class</span> QX_DLL2_EXPORT BaseClassTrigger<span class="operator">
{</span>

   QX_REGISTER_FRIEND_CLASS<span class="operator">(</span>BaseClassTrigger<span class="operator">)</span><span class="keyword">

protected</span><span class="operator">:</span><span class="type">

   long</span>        m_id<span class="operator">;</span>
   QDateTime   m_dateCreation<span class="operator">;</span>
   QDateTime   m_dateModification<span class="operator">;</span>
   QString     m_userCreation<span class="operator">;</span>
   QString     m_userModification<span class="operator">;</span><span class="keyword">

public</span><span class="operator">:</span>

   BaseClassTrigger<span class="operator">() :</span> m_id<span class="operator">(</span><span class="int">0</span><span class="operator">)  { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>BaseClassTrigger<span class="operator">()   { ; }</span><span class="type">

   long</span> getId<span class="operator">()</span><span class="keyword"> const</span><span class="operator">                     {</span><span class="flow"> return</span> m_id<span class="operator">; }</span>
   QDateTime getDateCreation<span class="operator">()</span><span class="keyword"> const</span><span class="operator">      {</span><span class="flow"> return</span> m_dateCreation<span class="operator">; }</span>
   QDateTime getDateModification<span class="operator">()</span><span class="keyword"> const</span><span class="operator">  {</span><span class="flow"> return</span> m_dateModification<span class="operator">; }</span>
   QString getUserCreation<span class="operator">()</span><span class="keyword"> const</span><span class="operator">        {</span><span class="flow"> return</span> m_userCreation<span class="operator">; }</span>
   QString getUserModification<span class="operator">()</span><span class="keyword"> const</span><span class="operator">    {</span><span class="flow"> return</span> m_userModification<span class="operator">; }</span><span class="type">

   void</span> setId<span class="operator">(</span><span class="type">long</span> l<span class="operator">)                              {</span> m_id<span class="operator"> =</span> l<span class="operator">; }</span><span class="type">
   void</span> setDateCreation<span class="operator">(</span><span class="keyword">const</span> QDateTime<span class="operator"> &amp;</span> dt<span class="operator">)      {</span> m_dateCreation<span class="operator"> =</span> dt<span class="operator">; }</span><span class="type">
   void</span> setDateModification<span class="operator">(</span><span class="keyword">const</span> QDateTime<span class="operator"> &amp;</span> dt<span class="operator">)  {</span> m_dateModification<span class="operator"> =</span> dt<span class="operator">; }</span><span class="type">
   void</span> setUserCreation<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> s<span class="operator">)         {</span> m_userCreation<span class="operator"> =</span> s<span class="operator">; }</span><span class="type">
   void</span> setUserModification<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> s<span class="operator">)     {</span> m_userModification<span class="operator"> =</span> s<span class="operator">; }</span><span class="type">

   void</span> onBeforeInsert<span class="operator">(</span>qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">);</span><span class="type">
   void</span> onBeforeUpdate<span class="operator">(</span>qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">);

};</span>

QX_REGISTER_HPP_QX_DLL2<span class="operator">(</span>BaseClassTrigger<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
namespace</span> dao<span class="operator"> {</span><span class="keyword">
namespace</span> detail<span class="operator"> {</span><span class="keyword">

template</span><span class="operator"> &lt;&gt;</span><span class="keyword">
struct</span> QxDao_Trigger<span class="operator">&lt;</span>BaseClassTrigger<span class="operator">&gt;
{</span><span class="keyword">

   static inline</span><span class="type"> void</span> onBeforeInsert<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span><span class="flow"> if</span><span class="operator"> (</span>t<span class="operator">) {</span> t<span class="operator">-&gt;</span>onBeforeInsert<span class="operator">(</span>dao<span class="operator">); } }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onBeforeUpdate<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span><span class="flow"> if</span><span class="operator"> (</span>t<span class="operator">) {</span> t<span class="operator">-&gt;</span>onBeforeUpdate<span class="operator">(</span>dao<span class="operator">); } }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onBeforeDelete<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onAfterInsert<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onAfterUpdate<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onAfterDelete<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }

};

}</span><span class="comment"> // namespace detail
</span><span class="operator">}</span><span class="comment"> // namespace dao
</span><span class="operator">}</span><span class="comment"> // namespace qx
</span><span class="pre">
#endif // _QX_BASE_CLASS_TRIGGER_H_
</span></pre>
           </td></tr></tbody></table>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#include "../include/precompiled.h"
#include "../include/BaseClassTrigger.h"
#include &lt;QxMemLeak.h&gt;
</span>
QX_REGISTER_CPP_QX_DLL2<span class="operator">(</span>BaseClassTrigger<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>BaseClassTrigger<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   IxDataMember<span class="operator"> *</span> pData<span class="operator"> =</span> NULL<span class="operator">;</span>

   pData<span class="operator"> =</span> t<span class="operator">.</span>id<span class="operator">(&amp;</span> BaseClassTrigger<span class="operator">::</span>m_id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>

   pData<span class="operator"> =</span> t<span class="operator">.</span>data<span class="operator">(&amp;</span> BaseClassTrigger<span class="operator">::</span>m_dateCreation<span class="operator">,</span><span class="string"> "date_creation"</span><span class="operator">);</span>
   pData<span class="operator"> =</span> t<span class="operator">.</span>data<span class="operator">(&amp;</span> BaseClassTrigger<span class="operator">::</span>m_dateModification<span class="operator">,</span><span class="string"> "date_modification"</span><span class="operator">);</span>
   pData<span class="operator"> =</span> t<span class="operator">.</span>data<span class="operator">(&amp;</span> BaseClassTrigger<span class="operator">::</span>m_userCreation<span class="operator">,</span><span class="string"> "user_creation"</span><span class="operator">);</span>
   pData<span class="operator"> =</span> t<span class="operator">.</span>data<span class="operator">(&amp;</span> BaseClassTrigger<span class="operator">::</span>m_userModification<span class="operator">,</span><span class="string"> "user_modification"</span><span class="operator">);
}}</span><span class="type">

void</span> BaseClassTrigger<span class="operator">::</span>onBeforeInsert<span class="operator">(</span>qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
{</span>
   Q_UNUSED<span class="operator">(</span>dao<span class="operator">);</span>
   m_dateCreation<span class="operator"> =</span> QDateTime<span class="operator">::</span>currentDateTime<span class="operator">();</span>
   m_dateModification<span class="operator"> =</span> QDateTime<span class="operator">::</span>currentDateTime<span class="operator">();</span>
   m_userCreation<span class="operator"> =</span><span class="string"> "current_user_1"</span><span class="operator">;</span>
   m_userModification<span class="operator"> =</span><span class="string"> "current_user_1"</span><span class="operator">;
}</span><span class="type">

void</span> BaseClassTrigger<span class="operator">::</span>onBeforeUpdate<span class="operator">(</span>qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
{</span>
   Q_UNUSED<span class="operator">(</span>dao<span class="operator">);</span>
   m_dateModification<span class="operator"> =</span> QDateTime<span class="operator">::</span>currentDateTime<span class="operator">();</span>
   m_userModification<span class="operator"> =</span><span class="string"> "current_user_2"</span><span class="operator">;
}</span>
</pre>
           </td></tr></tbody></table>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_140"><u><b>Comment déclarer une classe abstraite dans le contexte QxOrm ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           Une classe abstraite C++ (contenant au moins une méthode virtuelle pure) ne peut pas être mappée avec une table d'une base de données (puisqu'elle ne peut pas être instanciée).<br>
           Cependant, il peut être intéressant de définir une classe abstraite contenant une liste de propriétés utilisées par plusieurs objets persistants.<br>
           Un exemple de classe abstraite se trouve dans le dossier <i>./test/qxDllSample/dll2/</i> de la distribution de QxOrm avec la classe <i>BaseClassTrigger</i>.<br>
           QxOrm propose le mécanisme suivant pour définir une classe abstraite dans le contexte QxOrm :
           <ul>
           <li>déclarer la classe avec la méthode '<i>void register_class</i>' comme n'importe qu'elle autre classe ;
           </li><li>utiliser la macro <b>QX_REGISTER_ABSTRACT_CLASS(className)</b> juste après la définition de la classe.
           </li></ul>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_150"><u><b>Comment déclarer une classe définie dans un espace de nom (<i>namespace</i>) dans le contexte QxOrm ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           Si une classe est définie dans un espace de nom (<i>namespace</i>), alors une erreur de compilation se produit avec l'utilisation des macros : <b>QX_REGISTER_HPP</b> et <b>QX_REGISTER_CPP</b>.<br>
           Pour éviter ces erreurs de compilation, il est nécessaire d'utiliser les macros suivantes : <b>QX_REGISTER_COMPLEX_CLASS_NAME_HPP</b> et <b>QX_REGISTER_COMPLEX_CLASS_NAME_CPP</b>.<br>
           Vous trouverez un exemple d'utilisation dans le dossier <i>./test/qxDllSample/dll1/</i> de la distribution de QxOrm avec la classe <i>CPerson</i> définie dans l'espace de nom <i>qx::test</i> :<br>
           <br>
           * <i><b>QX_REGISTER_COMPLEX_CLASS_NAME_HPP_QX_DLL1(qx::test::CPerson, QObject, 0, qx_test_CPerson)</b></i>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_160"><u><b>Comment utiliser le mécanisme de suppression logique (<i>soft delete</i>) ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           Une suppression logique permet de ne pas effacer de ligne dans une table d'une base de données (contrairement à une suppression physique) : une colonne supplémentaire est ajoutée à la définition de la table pour indiquer que la ligne est supprimée ou non.<br>
           Cette colonne peut contenir soit un booléen (1 signifie ligne supprimée, 0 ou vide signifie ligne non supprimée), soit la date-heure de suppression de la ligne (si vide, la ligne est considérée comme non supprimée).<br>
           Il est donc à tout moment possible de réactiver une ligne supprimée en réinitialisant la valeur à vide dans la table de la base de données.<br>
           <br>
           Pour activer le mécanisme de suppression logique avec la bibliothèque QxOrm, il faut utiliser la classe <b>qx::QxSoftDelete</b> dans la fonction de mapping <i>qx::register_class&lt;T&gt;</i>.<br>
           Voici un exemple d'utilisation avec une classe <i>Bar</i> contenant deux propriétés <i>m_id</i> et <i>m_desc</i> :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>Bar<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   t<span class="operator">.</span>setSoftDelete<span class="operator">(</span>qx<span class="operator">::</span>QxSoftDelete<span class="operator">(</span><span class="string">"deleted_at"</span><span class="operator">));</span>

   t<span class="operator">.</span>id<span class="operator">(&amp;</span> Bar<span class="operator">::</span>m_id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> Bar<span class="operator">::</span>m_desc<span class="operator">,</span><span class="string"> "desc"</span><span class="operator">);
}}</span></pre>
           </td></tr></tbody></table>
           <br>
           Les requêtes SQL générées automatiquement par la bibliothèque QxOrm vont prendre en compte ce paramètre de suppression logique pour ajouter les conditions nécessaires (ne pas récupérer les éléments supprimés, ne pas supprimer physiquement une ligne, etc.).<br>
           Par exemple, si vous exécutez les lignes suivantes avec la classe <i>Bar</i> :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>Bar_ptr pBar<span class="operator">;</span> pBar<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> Bar<span class="operator">());</span>
pBar<span class="operator">-&gt;</span>setId<span class="operator">(</span><span class="int">5</span><span class="operator">);</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>delete_by_id<span class="operator">(</span>pBar<span class="operator">);</span>     qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">());</span>
qx_bool bDaoExist<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>exist<span class="operator">(</span>pBar<span class="operator">);</span>             qAssert<span class="operator">(!</span> bDaoExist<span class="operator">);</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>delete_all<span class="operator">&lt;</span>Bar<span class="operator">&gt;();</span>                qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">());</span><span class="type">
long</span> lBarCount<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>count<span class="operator">&lt;</span>Bar<span class="operator">&gt;();</span>               qAssert<span class="operator">(</span>lBarCount<span class="operator"> ==</span><span class="int"> 0</span><span class="operator">);</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>destroy_all<span class="operator">&lt;</span>Bar<span class="operator">&gt;();</span>               qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">());</span></pre>
           </td></tr></tbody></table>
           <br>
           Vous obtiendrez les traces suivantes :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="operator">[</span>QxOrm<span class="operator">]</span> sql query<span class="operator"> (</span><span class="int">93</span> ms<span class="operator">) :</span> UPDATE Bar SET deleted_at<span class="operator"> =</span><span class="char"> '20110617115148615'</span> WHERE id<span class="operator"> = :</span>id<span class="operator">
[</span>QxOrm<span class="operator">]</span> sql query<span class="operator"> (</span><span class="int">0</span> ms<span class="operator">) :</span> SELECT Bar<span class="operator">.</span>id AS Bar_id_0<span class="operator">,</span> Bar<span class="operator">.</span>deleted_at FROM Bar WHERE Bar<span class="operator">.</span>id<span class="operator"> = :</span>id AND<span class="operator"> (</span>Bar<span class="operator">.</span>deleted_at IS NULL OR Bar<span class="operator">.</span>deleted_at<span class="operator"> =</span><span class="char"> ''</span><span class="operator">)
[</span>QxOrm<span class="operator">]</span> sql query<span class="operator"> (</span><span class="int">78</span> ms<span class="operator">) :</span> UPDATE Bar SET deleted_at<span class="operator"> =</span><span class="char"> '20110617115148724'</span><span class="operator">
[</span>QxOrm<span class="operator">]</span> sql query<span class="operator"> (</span><span class="int">0</span> ms<span class="operator">) :</span> SELECT COUNT<span class="operator">(*)</span> FROM Bar WHERE<span class="operator"> (</span>Bar<span class="operator">.</span>deleted_at IS NULL OR Bar<span class="operator">.</span>deleted_at<span class="operator"> =</span><span class="char"> ''</span><span class="operator">)
[</span>QxOrm<span class="operator">]</span> sql query<span class="operator"> (</span><span class="int">110</span> ms<span class="operator">) :</span> DELETE FROM Bar</pre>
           </td></tr></tbody></table>
           <br>
           <b>Remarque :</b> pour supprimer physiquement une ligne de la base de données, il faut utiliser les fonctions : <i>qx::dao::destroy_by_id()</i> et <i>qx::dao::destroy_all()</i>.<br>
           <br>
           <b>Autre remarque :</b> il peut être intéressant de définir au niveau du SGBD un index sur la colonne <i>deleted_at</i> (ou peu importe le nom que vous donnez) afin d'accélérer l'exécution des requêtes SQL.<br>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_170"><u><b>Comment utiliser les sessions (classe <i>qx::QxSession</i>) pour simplifier la gestion des transactions des bases de données (C++ RAII) ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
            <a href="http://knol.google.com/k/les-transactions-base-de-données" target="_blank"><b>Une transaction</b></a> est une suite d'opérations effectuées comme une seule unité logique de travail.<br>
            Une fois terminée, la transaction est :<br>
            * soit validée (<b>commit</b>), alors toutes les modifications sont faites dans la base de données ;<br>
            * soit annulée (<b>rollback</b>), alors toutes les modifications ne sont pas enregistrée.<br>
            <br>
            La classe <b>qx::QxSession</b> de la bibliothèque QxOrm permet de gérer automatiquement les transactions (validation, annulation) en utilisant le mécanisme <a href="http://fr.wikipedia.org/wiki/RAII" target="_blank">C++ RAII</a> :<br>
            <br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="operator">{</span><span class="comment"> // Ouverture d'un scope où une session sera instanciée

  // Création d'une session : une connection valide à la BDD est assignée à la session et une transaction est démarrée
  </span>qx<span class="operator">::</span>QxSession session<span class="operator">;</span><span class="comment">

  // Exécution d'une série d'opérations avec la BDD (en utilisant l'opérateur += de la classe qx::QxSession et la connection de la session)
  </span>session<span class="operator"> +=</span> qx<span class="operator">::</span>dao<span class="operator">::</span>insert<span class="operator">(</span>my_object<span class="operator">,</span> session<span class="operator">.</span>database<span class="operator">());</span>
  session<span class="operator"> +=</span> qx<span class="operator">::</span>dao<span class="operator">::</span>update<span class="operator">(</span>my_object<span class="operator">,</span> session<span class="operator">.</span>database<span class="operator">());</span>
  session<span class="operator"> +=</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id<span class="operator">(</span>my_object<span class="operator">,</span> session<span class="operator">.</span>database<span class="operator">());</span>
  session<span class="operator"> +=</span> qx<span class="operator">::</span>dao<span class="operator">::</span>delete_by_id<span class="operator">(</span>my_object<span class="operator">,</span> session<span class="operator">.</span>database<span class="operator">());</span><span class="comment">

  // Si la session n'est pas valide (donc une erreur s'est produite) =&gt; affichage de la 1ère erreur de la session
  </span><span class="flow">if</span><span class="operator"> (!</span> session<span class="operator">.</span>isValid<span class="operator">()) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] session error : '%s'"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>session<span class="operator">.</span>firstError<span class="operator">().</span>text<span class="operator">())); }

}</span><span class="comment"> // Fermeture du scope : la session est détruite (transaction =&gt; commit ou rollback automatique)</span></pre>
            </td></tr></tbody></table>
            <br>
            <b>Remarque :</b> une session peut déclencher une exception de type <i>qx::dao::sql_error</i> lorsqu'une erreur se produit (par défaut, aucune exception n'est déclenchée). Il est possible de paramétrer ce comportement en utilisant :<br>
            * soit le constructeur de la classe <i>qx::QxSession</i> (pour une session en particulier) ;<br>
            * soit le paramètre du singleton <i>qx::QxSqlDatabase::getSingleton()->setSessionThrowable(bool b)</i> (pour toutes les sessions).<br>
            <br>
            <b>Autre remarque :</b> il est important de ne pas oublier de passer la connection à la base de données de la session à chaque fonction <i>qx::dao::xxx</i> (en utilisant la méthode <i>session.database()</i>).<br>
            De plus, il est possible d'initialiser une session avec sa propre connection (provenant d'un pool de connections par exemple) en utilisant le constructeur de la classe <i>qx::QxSession</i>.<br>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      </td>
    </tr>
  </tbody>
</table>
<br><hr style="width: 80%" align="center" size="1" color="#100D5A">
<table border="0" style="width: 80%" align="center">
  <col><col>
  <tbody>
    <tr>
      <td align="left" valign="middle"><img alt="QxOrm"
        src="./resource/logo_qxorm_small.jpg" width="168" height="40"></td>
      <td align="right" valign="middle"><font size="2"></font> </td>
    </tr>
  </tbody>
</table>
</body>
</html>
