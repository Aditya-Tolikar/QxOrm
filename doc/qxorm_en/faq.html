<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
  <title>QxOrm - C++ Object Relational Mapping library (ORM)</title>
  <meta name="generator" content="Amaya, see http://www.w3.org/Amaya/">
  <style type="text/css">
   .comment { color: #008000; font-style: italic; }
   .pre { color: #000099; }
   .string { color: #DF0101; }
   .char { color: #009900; }
   .float { color: #996600; }
   .int { color: #999900; }
   .bool { color: #000000; font-weight: bold; }
   .type { color: #FF6633; }
   .flow { color: #FF0000; }
   .keyword { color: #990000; }
   .operator { color: #663300; font-weight: bold; }
   .operator { color: #663300; font-weight: bold; }
  </style>
</head>
<body>
<table border="0" style="width: 80%" align="center">
  <col><col><col>
  <tbody>
    <tr>
      <td><a href="./home.html"><img alt="QxOrm" src="./resource/logo_qxorm.jpg" width="256" height="61" align="left" border="0"></a></td>
      <td align="right" style="vertical-align:bottom">
        <img alt="Windows" src="./resource/logo_windows.gif" width="35" height="35">
        <img alt="Linux" src="./resource/logo_linux.gif" width="35" height="35">
        <img alt="Macintosh" src="./resource/logo_mac.gif" width="35" height="35">
      </td>
      <td width="70"><img alt="C++" src="./resource/logo_cpp.jpg" width="50" height="50" align="right"></td>
    </tr>
  </tbody>
</table>
<hr style="width: 80%" align="center" size="1" color="#100D5A">
<table border="0" style="width: 80%" align="center">
  <col><col><col><col><col><col>
  <tbody>
    <tr>
      <td align="center"><a href="./home.html"><img alt="Home"
        src="./resource/link_home.jpg" width="120" height="35"
        style="border:1px solid #100D5A; border-color:#100D5A;"></a></td>
      <td align="center"><a href="./download.html"><img alt="Download"
        src="./resource/link_download.jpg" width="120" height="35"
        style="border:1px solid #100D5A; border-color:#100D5A;"></a></td>
      <td align="center"><a href="./quick_sample.html"><img alt="Quick sample"
        src="./resource/link_quick_sample.jpg" width="120" height="35"
        style="border:1px solid #100D5A; border-color:#100D5A;"></a></td>
      <td align="center"><a href="./tutorial.html"><img alt="Tutorial"
        src="./resource/link_tutorial.jpg" width="120" height="35"
        style="border:1px solid #100D5A; border-color:#100D5A;"></a></td>
      <td align="center"><a href="./faq.html"><img alt="Faq"
        src="./resource/link_faq.jpg" width="120" height="35"
        style="border:1px solid #100D5A; border-color:#100D5A;"></a></td>
      <td align="center"><a href="./link.html"><img alt="Link"
        src="./resource/link_link.jpg" width="120" height="35"
        style="border:1px solid #100D5A; border-color:#100D5A;"></a></td>
    </tr>
  </tbody>
</table>
<hr style="width: 80%" align="center" size="1" color="#100D5A">
<table border="0" style="width: 80%" align="center">
  <col><col><col><col><col>
  <tbody><tr>
  <td align="left" valign="top"><font size="2">QxOrm  &gt;&gt;  Faq</font></td>
  <td align="right" valign="top"><font size="2">Current version : QxOrm 1.1.9 (LGPL) - <a href="../doxygen/index.html" target="_blank">QxOrm library online documentation</a></font></td>
  <td width="10px"></td>
  <td width="40px" height="30px"><a href="../qxorm_fr/faq.html"><img alt="Version française du site" src="./resource/FR.png" width="40" height="30" border="0"></a></td>
  <td width="40px" height="30px"><a href="../qxorm_en/faq.html"><img alt="Web site english version" src="./resource/GB.png" width="40" height="30" border="0"></a></td>
  </tr></tbody>
</table>
<table border="1" frame="vsides" rules="cols" style="width: 80%" align="center" cellpadding="6" bgcolor="#F2F2F4">
  <col>
  <tbody>
    <tr>
      <td align="justify">
        <table border="0" style="width: 100%" align="center">
          <col><col>
          <tbody>
            <tr>
              <td><ul><li><a href="#faq_10">What is QxOrm ?</a><br>
               </li><li><a href="#faq_20">How to contact QxOrm to report a bug or ask a question ?</a><br>
               </li><li><a href="#faq_30">How to build QxOrm library ?</a><br>
               </li><li><a href="#faq_40">What are the databases supported by QxOrm ?</a><br>
               </li><li><a href="#faq_50">Why QxOrm is dependent on two libraries : boost and Qt ?</a><br>
               </li><li><a href="#faq_60">Why does QxOrm require a precompiled header to be used ?</a><br>
               </li><li><a href="#faq_70">Is it possible to reduce compilation times of my project ?</a><br>
               </li><li><a href="#faq_75">What are all types of <i>serialization</i> available ?</a><br>
               </li><li><a href="#faq_80">Why does QxOrm provide a new type of container <i>qx::QxCollection&lt;Key, Value&gt;</i> ?</a><br>
               </li><li><a href="#faq_81">Why does QxOrm provide a new smart-pointer <i>qx::dao::ptr&lt;T&gt;</i> ?</a><br>
               </li><li><a href="#faq_90">Should I use <i>QString</i> or <i>std::string</i> ?</a><br>
               </li><li><a href="#faq_95">Is it necessary to use <i>smart-pointers</i> ?</a><br>
               </li><li><a href="#faq_100">The primary key is <i>long</i> type by default. Is it possible to use a key of <i>QString</i> type or other ?</a><br>
               </li><li><a href="#faq_101">How to define a '<i>multi-columns primary key</i>' (<i>composite key</i>) ?</a><br>
               </li><li><a href="#faq_110">How to enable/disable the module <i>QxMemLeak</i> for automatic detection of memory leaks ?</a><br>
               </li><li><a href="#faq_120">How to manage inheritance and database ?</a><br>
               </li><li><a href="#faq_130">How to define a '<i>Trigger</i>' with QxOrm ?</a><br>
               </li><li><a href="#faq_140">How to register an abstract class into QxOrm context ?</a><br>
               </li><li><a href="#faq_150">How to register a class defined into a namespace into QxOrm context ?</a><br>
               </li><li><a href="#faq_160">How to define a soft delete behavior ?</a><br>
               </li><li><a href="#faq_170">How to use a session (<i>qx::QxSession</i> class) to manage automatically database transactions (using C++ RAII) ?</a><br>
               </li><li><a href="#faq_180">How to persist a type without its source code (class from an external library for example) ?</a><br>
               </li><li><a href="#faq_190">How to use introspection engine (or reflection engine) of QxOrm library ?</a><br>
               </li><li><a href="#faq_200">How to register automatically Qt meta-properties (using <i>Q_PROPERTY</i> macro) to QxOrm context ?</a><br>
               </li></ul>
              </td>
              <td width="200" align="center" valign="top"><a href="./resource/qt_ambassador_logo.png" target="_blank"><img alt="qt_ambassador" src="./resource/qt_ambassador_logo_150x150.png" width="150" height="150" border="0"></a><br>
                 <b><font size="2">QxOrm library has been accepted into the <a href="http://qt.nokia.com/qt-in-use/ambassadors/qtambassador/" target="_blank">Qt Ambassador Program</a></font></b>
              </td>
            </tr>
          </tbody>
        </table>
      <br>
      <a name="faq_10"><u><b>What is QxOrm ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           <b>QxOrm is a C++ library designed to provide <i>Object Relational Mapping (ORM)</i> feature to C++ users.<br>
           QxOrm is developed by Lionel Marty, a software development engineer since 2003.</b>
           <br>
           <b>QxOrm</b> provides many functionalities starting from a simple <i>C++ setting function by class</i> :
           <ul>
             <li><b><font style="background-color:yellow">persistence</font></b> : communication with a lot of databases (with <i>1-1</i>, <i>1-n</i>, <i>n-1</i> and <i>n-n</i> relationships)
             </li>
             <li><b><font style="background-color:yellow">serialization</font></b> : binary and xml format
             </li>
             <li><b><font style="background-color:yellow">reflection</font></b> (or <b><font style="background-color:yellow">introspection</font></b>) : access to classes definitions, retrieve properties and call classes methods
             </li>
           </ul>
           </td>
         </tr>
       </tbody>
      </table>
      <br>
      <a name="faq_20"><u><b>How to contact QxOrm to report a bug or ask a question ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           If you find a bug or if you have a question about <b>QxOrm</b> library, you can send an e-mail to : <u><i>support@qxorm.com</i></u>.<br>
<b>QxOrm</b> is also available on the <a href="http://sourceforge.net/projects/qxorm/files/" target="_blank">SourceForge</a> site : platform hosting development projects of free software.<br>
A forum dedicated to <b>QxOrm</b> is available <a href="http://sourceforge.net/apps/phpbb/qxorm/" target="_blank">by clicking here</a>.
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_30"><u><b>How to build QxOrm library ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           <b>QxOrm</b> uses <b>qmake</b> process from <b>Qt</b> library to create <i>makefile</i> and build the project.<br>
           <b>qmake</b> is portable and multi-platform, so it works perfectly on Windows, Linux (Unix) and Mac.<br>
           To build <b>QxOrm</b> library, just execute following commands :<br>
           <i>qmake</i><br>
           <i>make debug</i><br>
           <i>make release</i><br>
           <br>
           On <b>Windows</b>, <i>*.vcproj</i> and <i>*.sln</i> files are available for <b>Visual C++ 2008</b> and <b>Visual C++ 2010</b>.<br>
           <i>*.pro</i> files are readable by <b>Qt Creator</b>, and some plugins are available to interface to other C++ IDE.<br>
           <i>mingw_build_all_debug.bat</i> and <i>mingw_build_all_release.bat</i> scripts in the directory <i>./tools/</i> can quickly built QxOrm library and all tests with <b>MinGW</b> compiler on Windows.<br>
           <i>gcc_build_all_debug.sh</i> and <i>gcc_build_all_release.sh</i> scripts in the directory <i>./tools/</i> can quickly built QxOrm library and all tests with <b>GCC</b> compiler on <b>Linux</b>.<br>
           <i>osx_build_all_debug.sh</i> and <i>osx_build_all_release.sh</i> scripts in the directory <i>./tools/</i> can quickly built QxOrm library and all tests on <b>Mac</b> (thanks very much to Dominique Billet).<br>
           <br>
           <b>Note :</b> depending on your development environment, it may be necessary to modify <u><b>QxOrm.pri</b></u> file to set <b>boost</b> package configuration :<br>
           <i>QX_BOOST_INCLUDE_PATH = $$quote(D:/Dvlp/_Libs/Boost/1_42/include)<br>
           QX_BOOST_LIB_PATH = $$quote(D:/Dvlp/_Libs/Boost/1_42/lib_shared)<br>
           QX_BOOST_LIB_SERIALIZATION_DEBUG = "boost_serialization-vc90-mt-gd-1_42"<br>
           QX_BOOST_LIB_SERIALIZATION_RELEASE = "boost_serialization-vc90-mt-1_42"<br></i>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_40"><u><b>What are the databases supported by QxOrm ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           <b>QxOrm</b> uses the engine <a href="http://doc.trolltech.com/4.6/sql-programming.html" target="_blank"><i>QtSql</i></a> of <b>Qt</b> based on a system of plug-in.<br>
A detailed list of supported databases is available on the website of Qt <a href="http://doc.trolltech.com/4.6/sql-driver.html" target="_blank">here</a>.<br> The plug-in <i>ODBC</i> (<i>QODBC</i>) ensures compatibility with many databases.<br> For optimal performances, it is possible to use a plug-in specific to a database :
           <ul><li><i>QMYSQL</i> : MySQL 
           </li><li><i>QPSQL</i> : PostgreSQL (versions 7.3 and above) 
           </li><li><i>QOCI</i> : Oracle Call Interfaces Driver 
           </li><li><i>QSQLITE</i> : SQLite version 3 
           </li><li><i>QDB2</i> : IBM DB2 (version 7.1 and above) 
           </li><li><i>QIBASE</i> : Borland InterBase 
           </li><li><i>QTDS</i> : Sybase Adaptive Server 
           </li></ul>
           </td>
         </tr>
       </tbody>
      </table>
      <br>
      <a name="faq_50"><u><b>Why QxOrm is dependent on two libraries : boost and Qt ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           <b>QxOrm</b> uses many functionalities available in excellent libraries : <b>boost</b> and <b>Qt</b>.<br>
           In addition, these two libraries are used in many projects both professional and open source.<br>
           A large number of forums, tutorials, and a whole community are available to answer any issue that could arise.<br>
           The <b>QxOrm</b> objective is not to redevelop features that already exist but to provide a powerful tool for access to databases such as it exists in other languages (<i>Java</i> with <i>Hibernate</i>, <i>.Net</i> with <i>NHibernate</i>, <i>Ruby</i>, <i>Python</i>, etc...).<br><br>
           <table border="0" style="width: 100%" align="center">
             <col><col>
             <tbody>
               <tr>
                 <td valign="middle" width="161" align="center"><a href="http://www.boost.org/" target="_blank"><img alt="boost" src="./resource/logo_boost.jpg" width="161" height="50" border="0"></a></td>
                 <td align="justify"><b>boost</b> : many of boost's founders are on the C++ standard committee and several boost libraries have been accepted for incorporation into C++1x (new standard for the C++ programming language).
                 The boost's libraries are aimed at a wide range of C++ users and application domains.<br>
                 QxOrm uses the following features of boost : <i>smart_pointer, serialization, type_traits, multi_index_container, unordered_container, any, tuple, foreach, function.</i><br>
                 It is recommended to install the latest version of boost available at the following address : <a href="http://www.boost.org/" target="_blank">http://www.boost.org/</a></td>
               </tr>
             </tbody>
           </table>
           <p></p>
           <table border="0" style="width: 100%" align="center">
             <col><col>
             <tbody>
               <tr>
                 <td valign="middle" width="161" align="center"><a href="http://qt.nokia.com/" target="_blank"><img alt="Qt" src="./resource/logo_qt.jpg" width="42" height="50" border="0"></a></td>
                 <td align="justify"><b>Qt</b> : cross-platform application development framework : ihm (<i>QtGui</i>), network (<i>QtNetwork</i>), xml (<i>QtXml</i>), database (<i>QtSql</i>)...<br>
                 Qt provides excellent support and documentation. Using Qt, you can write simple and powerful C++ code.<br>
                 Qt is produced by Nokia's Qt Development Frameworks division and is available under LGPL license.<br>
                 QxOrm is compatible with a lot of Qt's objects : <i>QObject, QString, QDate, QTime, QDateTime, QList, QHash, QSharedPointer, QScopedPointer...</i><br>
                 It is recommended to install the latest version of Qt available at the following address : <a href="http://qt.nokia.com/" target="_blank">http://qt.nokia.com/</a></td>
               </tr>
             </tbody>
           </table>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_60"><u><b>Why does QxOrm require a precompiled header to be used ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           <b>QxOrm</b> uses the techniques of <b>C++ meta-programming</b> to provide most of its functionalities.<br>
           You do not need to know how to use meta-programming to work with <b>QxOrm</b> library.<br>
           Indeed, QxOrm is simple to use and the C++ code written with Qt and QxOrm is easy to read, therefore easy to develop and to maintain.<br><br>
           However, meta-programming is costly in compilation times.<br>
           By using a <i>precompiled.h</i> file, your project will be compiled much more quickly.<br>
           Last but not least, another advantage is that the file <i>QxOrm.h</i> includes the basic functionalities of libraries boost and Qt.<br>
           It is thus not necessary anymore to write <i>#include &lt;QtCore/QString.h&gt;</i> to use the class QString of Qt for example.<br>
           In the same way, there is no need anymore to write <i>#include &lt;boost/shared_ptr.hpp&gt;</i> to use smart pointers of boost library.
           </td> 
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_70"><u><b>Is it possible to reduce compilation times of my project ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           Yes, if the <i>serialization</i> of your data in <i>xml</i> format is not used in your project, you can disable this functionality.<br>
           The compilation times will be then reduced but you will not have anymore access to the namespace <i>qx::serialization:xml</i>.<br>
           To disable <i>xml serialization</i>, it is necessary to open the <i>QxConfig.h</i> file and to modify the constant <b><i>_QX_SERIALIZE_XML</i></b>.<br>
           A recompilation of QxOrm library is necessary to take into account this modification.<br>
           <br>
           Another possibility is to use the <i>polymorphic</i> classes of the library <a href="http://www.boost.org/doc/libs/1_42_0/libs/serialization/doc/index.html" target="_blank"><i>boost::serialization</i></a> (instead of <i>template</i>).<br>
           This feature reduces compilation times and the size of the executable that is generated.<br>
           However, the speed of execution of your program will be reduced since part of the work carried out during compilation will be done during the execution of your application.<br>
           To activate this feature in <b>QxOrm</b>, you must modify the constant <b><i>_QX_SERIALIZE_POLYMORPHIC</i></b> of the <i>QxConfig.h</i> file.<br>
           <b>Warning</b> : the <i>serialization</i> functions will be then accessible from the following <i>namespace</i> : <i>qx::serialization::polymorphic_binary</i>, <i>qx::serialization::polymorphic_text</i> and <i>qx::serialization::polymorphic_xml</i>.<br>
           A recompilation of QxOrm library is necessary to take into account this modification.<br>
           <br>
           It is also possible to use <i>Q_PROPERTY</i> macro to define properties for a class inherited from <i>QObject</i> type.<br>
           In this case, there is two different ways to register properties into QxOrm context and you can reduce noticeably compilation times of your project.<br>
           For more details about this feature, <a href="./faq.html#faq_200">click here</a>.
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_75"><u><b>What are all types of <i>serialization</i> available ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           <b>QxOrm</b> is based on <a href="http://www.boost.org/doc/libs/1_42_0/libs/serialization/doc/index.html" target="_blank">boost <i>serialization</i></a> library.<br>
           There are several types of serialization available : <i>binary, xml, text, etc...</i><br>
           <i>QxConfig.h</i> file can enable and/or disable some types of serialization.<br>
           <br>
           Each type of serialization has its own characteristics :<br>
           * <b>binary</b> : <i>smallest, fastest, non-portable</i><br>
           * <b>text</b> : <i>larger, slower, portable</i><br>
           * <b>xml</b> : <i>largest, slowest, portable</i><br>
           <br>
           <b>Note :</b> <b>binary</b> type is not portable, so you can't transfer data between Windows and Unix for example.<br>
           If you need to transfer data over network between different platforms, you have to use <b>text</b> or <b>xml</b> serialization.<br>
           <b>QxOrm</b> provides another solution : <b><a href="http://www.boostpro.com/vault/index.php?directory=serialization" target="_blank">portable_binary</a></b> serialization.<br>
           <b>portable_binary</b> has the same characteristics as <b>binary</b> type and can serialize data in a portable way.<br>
           However, <b>portable_binary</b> is not provided officially by <b>boost</b> library, so it's necessary to test before using in a production software.
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_80"><u><b>Why does QxOrm provide a new type of container <i>qx::QxCollection&lt;Key, Value&gt;</i> ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           There are many containers in <b>stl</b>, <b>boost</b> and <b>Qt</b> libraries.<br>
           It is therefore legitimate to ask this question : what is <i>qx::QxCollection&lt;Key, Value&gt;</i> ?<br>
           <i>qx::QxCollection&lt;Key, Value&gt;</i> is a new <i>container</i> (based on the excellent library <a href="http://www.boost.org/doc/libs/1_42_0/libs/multi_index/doc/index.html" target="_blank"><i>boost::multi_index_container</i></a>) which has the following functionalities : 
           <ul><li>preserves the insertion order of elements in the list 
           </li><li>quick access to an element by its index : is equivalent to <i>std::vector&lt;T&gt;</i> or <i>QList&lt;T&gt;</i> for example 
           </li><li>quick access to an element by a key (<i>hash-map</i>) : is equivalent to <i>QHash&lt;Key, Value&gt;</i> or <i>boost::unordered_map&lt;Key, Value&gt;</i> for example 
           </li><li>sort by <i>Key</i> type and by <i>Value</i> type</li>
           </ul>
           <b>Note :</b> <i>qx::QxCollection&lt;Key, Value&gt;</i> is compatible with the <i>foreach</i> macro provided by <b>Qt</b> library and the <a href="http://www.boost.org/doc/libs/1_42_0/doc/html/foreach.html" target="_blank"><i>BOOST_FOREACH</i></a> macro provided by <b>boost</b> library.<br>
           However, each element returned by these 2 macros corresponds to an object of type <i>std::pair&lt;Key, Value&gt;</i>.<br>
           To obtain a more natural and more readable result, it is advised to use the <i>_foreach</i> macro : this macro uses <i>BOOST_FOREACH</i> for all the containers except for <i>qx::QxCollection&lt;Key, Value&gt;</i>.<br>
           In this case, the returned element corresponds to the <i>Value</i> type (cf. <i>sample</i>).<br>
           The macro <i>_foreach</i> is compatible with all <i>containers</i> (<b>stl</b>, <b>Qt</b>, <b>boost</b>...) since it uses the macro <i>BOOST_FOREACH</i>.<br><br>

           <b>Additional note :</b> <i>qx::QxCollection&lt;Key, Value&gt;</i> is particularly suited to receive data resulting from a database.<br> Indeed, these data can be sorted (by using <i>ORDER BY</i> in a sql request for example), it is thus important to preserve the insertion order of the elements in the list.<br>
           Furthermore, each data resulting from a database has a unique id. It is thus important to be able to access quickly to an element based on this single identifier (<i>hash-map</i>).<br><br>

           <b>Sample :</b><br> 
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">/* definition of drug class with 3 properties : code, name, description */</span><span class="keyword">
class</span> drug<span class="operator"> {</span><span class="keyword"> public</span><span class="operator">:</span> QString code<span class="operator">;</span> QString name<span class="operator">;</span> QString desc<span class="operator">; };</span><span class="comment">

/* smart pointer of drug */</span><span class="keyword">
typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>drug<span class="operator">&gt;</span> drug_ptr<span class="operator">;</span><span class="comment">

/* collection of drugs by code */</span>
qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span>QString<span class="operator">,</span> drug_ptr<span class="operator">&gt;</span> lstDrugs<span class="operator">;</span><span class="comment">

/* create 3 new drugs */</span>
drug_ptr d1<span class="operator">;</span> d1<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span> d1<span class="operator">-&gt;</span>code<span class="operator"> =</span><span class="string"> "code1"</span><span class="operator">;</span> d1<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name1"</span><span class="operator">;</span> d1<span class="operator">-&gt;</span>desc<span class="operator"> =</span><span class="string"> "desc1"</span><span class="operator">;</span>
drug_ptr d2<span class="operator">;</span> d2<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span> d2<span class="operator">-&gt;</span>code<span class="operator"> =</span><span class="string"> "code2"</span><span class="operator">;</span> d2<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name2"</span><span class="operator">;</span> d2<span class="operator">-&gt;</span>desc<span class="operator"> =</span><span class="string"> "desc2"</span><span class="operator">;</span>
drug_ptr d3<span class="operator">;</span> d3<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span> d3<span class="operator">-&gt;</span>code<span class="operator"> =</span><span class="string"> "code3"</span><span class="operator">;</span> d3<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name3"</span><span class="operator">;</span> d3<span class="operator">-&gt;</span>desc<span class="operator"> =</span><span class="string"> "desc3"</span><span class="operator">;</span><span class="comment">

/* insert drugs into the collection */</span>
lstDrugs<span class="operator">.</span>insert<span class="operator">(</span>d1<span class="operator">-&gt;</span>code<span class="operator">,</span> d1<span class="operator">);</span>
lstDrugs<span class="operator">.</span>insert<span class="operator">(</span>d2<span class="operator">-&gt;</span>code<span class="operator">,</span> d2<span class="operator">);</span>
lstDrugs<span class="operator">.</span>insert<span class="operator">(</span>d3<span class="operator">-&gt;</span>code<span class="operator">,</span> d3<span class="operator">);</span><span class="comment">

/* iterate with '_foreach' keyword */</span>
_foreach<span class="operator">(</span>drug_ptr p<span class="operator">,</span> lstDrugs<span class="operator">)
{</span> qDebug<span class="operator">() &lt;&lt;</span> qPrintable<span class="operator">(</span>p<span class="operator">-&gt;</span>name<span class="operator">) &lt;&lt;</span><span class="string"> " "</span><span class="operator"> &lt;&lt;</span> qPrintable<span class="operator">(</span>p<span class="operator">-&gt;</span>desc<span class="operator">); }</span><span class="comment">

/* iterate with 'for' keyword */</span><span class="flow">
for</span><span class="operator"> (</span><span class="type">long</span> l<span class="operator"> =</span><span class="int"> 0</span><span class="operator">;</span> l<span class="operator"> &lt;</span> lstDrugs<span class="operator">.</span>count<span class="operator">(); ++</span>l<span class="operator">)
{</span>
   drug_ptr p<span class="operator"> =</span> lstDrugs<span class="operator">.</span>getByIndex<span class="operator">(</span>l<span class="operator">);</span>
   QString code<span class="operator"> =</span> lstDrugs<span class="operator">.</span>getKeyByIndex<span class="operator">(</span>l<span class="operator">);</span>
   qDebug<span class="operator">() &lt;&lt;</span> qPrintable<span class="operator">(</span>p<span class="operator">-&gt;</span>name<span class="operator">) &lt;&lt;</span><span class="string"> " "</span><span class="operator"> &lt;&lt;</span> qPrintable<span class="operator">(</span>p<span class="operator">-&gt;</span>desc<span class="operator">);
}</span><span class="comment">

/* iterate with 'QxCollectionIterator' java style */</span>
qx<span class="operator">::</span>QxCollectionIterator<span class="operator">&lt;</span>QString<span class="operator">,</span> drug_ptr<span class="operator">&gt;</span> itr<span class="operator">(</span>lstDrugs<span class="operator">);</span><span class="flow">
while</span><span class="operator"> (</span>itr<span class="operator">.</span>next<span class="operator">())
{</span>
   QString code<span class="operator"> =</span> itr<span class="operator">.</span>key<span class="operator">();</span>
   qDebug<span class="operator">() &lt;&lt;</span> qPrintable<span class="operator">(</span>itr<span class="operator">.</span>value<span class="operator">()-&gt;</span>name<span class="operator">) &lt;&lt;</span><span class="string"> " "</span><span class="operator"> &lt;&lt;</span> qPrintable<span class="operator">(</span>itr<span class="operator">.</span>value<span class="operator">()-&gt;</span>desc<span class="operator">);
}</span><span class="comment">

/* sort ascending by key and sort descending by value */</span>
lstDrugs<span class="operator">.</span>sortByKey<span class="operator">(</span><span class="bool">true</span><span class="operator">);</span>
lstDrugs<span class="operator">.</span>sortByValue<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="comment">

/* access drug by code */</span>
drug_ptr p<span class="operator"> =</span> lstDrugs<span class="operator">.</span>getByKey<span class="operator">(</span><span class="string">"code2"</span><span class="operator">);</span><span class="comment">

/* access drug by index */</span>
drug_ptr p<span class="operator"> =</span> lstDrugs<span class="operator">.</span>getByIndex<span class="operator">(</span><span class="int">2</span><span class="operator">);</span><span class="comment">

/* test if drug exists and if collection is empty */</span><span class="type">
bool</span> bExist<span class="operator"> =</span> lstDrugs<span class="operator">.</span>exist<span class="operator">(</span><span class="string">"code3"</span><span class="operator">);</span><span class="type">
bool</span> bEmpty<span class="operator"> =</span> lstDrugs<span class="operator">.</span>empty<span class="operator">();</span><span class="comment">

/* remove the second drug from collection */</span>
lstDrugs<span class="operator">.</span>removeByIndex<span class="operator">(</span><span class="int">2</span><span class="operator">);</span><span class="comment">

/* remove the drug with "code3" */</span>
lstDrugs<span class="operator">.</span>removeByKey<span class="operator">(</span><span class="string">"code3"</span><span class="operator">);</span><span class="comment">

/* clear the collection */</span>
lstDrugs<span class="operator">.</span>clear<span class="operator">();</span></pre>
           </td></tr></tbody></table>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_81"><u><b>Why does QxOrm provide a new smart-pointer <i>qx::dao::ptr&lt;T&gt;</i> ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           <b>QxOrm</b> can be used with smart-pointers of <b>boost</b> and <b>Qt</b> libraries.<br>
           <b>QxOrm</b> smart-pointer is based on <i>QSharedPointer</i> and provides new features with '<i>qx::dao::...</i>' functions.<br>
           <i>qx::dao::ptr&lt;T&gt;</i> keeps automatically values from database.<br>
           So it's possible to detect if an instance has been modified using the method '<i>isDirty()</i>' : this method can return list of properties changed.<br>
           <i>qx::dao::ptr&lt;T&gt;</i> can also be used with the function '<i>qx::dao::update_optimized()</i>' to update in database only properties changed.<br>
           <i>qx::dao::ptr&lt;T&gt;</i> can be used with a simple object and with many containers : <i>stl</i>, <i>boost</i>, <i>Qt</i> and <i>qx::QxCollection&lt;Key, Value&gt;</i>.<br>
           <br>
           <b>Sample :</b><br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">   // Test 'isDirty()' method
</span>   qx<span class="operator">::</span>dao<span class="operator">::</span>ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_isdirty<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;(</span><span class="keyword">new</span> blog<span class="operator">());</span>
   blog_isdirty<span class="operator">-&gt;</span>m_id<span class="operator"> =</span> blog_1<span class="operator">-&gt;</span>m_id<span class="operator">;</span>
   daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id<span class="operator">(</span>blog_isdirty<span class="operator">);</span>
   qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">() &amp;&amp; !</span> blog_isdirty<span class="operator">.</span>isDirty<span class="operator">());</span>

   blog_isdirty<span class="operator">-&gt;</span>m_text<span class="operator"> =</span><span class="string"> "blog property 'text' modified =&gt; blog is dirty !!!"</span><span class="operator">;</span>
   QStringList lstDiff<span class="operator">;</span><span class="type"> bool</span> bDirty<span class="operator"> =</span> blog_isdirty<span class="operator">.</span>isDirty<span class="operator">(</span>lstDiff<span class="operator">);</span>
   qAssert<span class="operator">(</span>bDirty<span class="operator"> &amp;&amp; (</span>lstDiff<span class="operator">.</span>count<span class="operator">() ==</span><span class="int"> 1</span><span class="operator">) &amp;&amp; (</span>lstDiff<span class="operator">.</span>at<span class="operator">(</span><span class="int">0</span><span class="operator">) ==</span><span class="string"> "blog_text"</span><span class="operator">));</span><span class="flow">
   if</span><span class="operator"> (</span>bDirty<span class="operator">) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] test dirty 1 : blog is dirty =&gt; '%s'"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>lstDiff<span class="operator">.</span>join<span class="operator">(</span><span class="string">"|"</span><span class="operator">))); }</span><span class="comment">

   // Update only property 'm_text' of 'blog_isdirty'
</span>   daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>update_optimized<span class="operator">(</span>blog_isdirty<span class="operator">);</span>
   qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">() &amp;&amp; !</span> blog_isdirty<span class="operator">.</span>isDirty<span class="operator">());</span>
   qx<span class="operator">::</span>dump<span class="operator">(</span>blog_isdirty<span class="operator">);</span><span class="comment">

   // Test 'isDirty()' method with a container
</span><span class="keyword">   typedef</span> qx<span class="operator">::</span>dao<span class="operator">::</span>ptr<span class="operator">&lt;</span> QList<span class="operator">&lt;</span>author_ptr<span class="operator">&gt; &gt;</span> type_lst_author_test_is_dirty<span class="operator">;</span>

   type_lst_author_test_is_dirty container_isdirty<span class="operator"> =</span> type_lst_author_test_is_dirty<span class="operator">(</span><span class="keyword">new</span> QList<span class="operator">&lt;</span>author_ptr<span class="operator">&gt;());</span>
   daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_all<span class="operator">(</span>container_isdirty<span class="operator">);</span>
   qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">() &amp;&amp; !</span> container_isdirty<span class="operator">.</span>isDirty<span class="operator">() &amp;&amp; (</span>container_isdirty<span class="operator">-&gt;</span>count<span class="operator">() ==</span><span class="int"> 3</span><span class="operator">));</span>

   author_ptr author_ptr_dirty<span class="operator"> =</span> container_isdirty<span class="operator">-&gt;</span>at<span class="operator">(</span><span class="int">1</span><span class="operator">);</span>
   author_ptr_dirty<span class="operator">-&gt;</span>m_name<span class="operator"> =</span><span class="string"> "author name modified at index 1 =&gt; container is dirty !!!"</span><span class="operator">;</span>
   bDirty<span class="operator"> =</span> container_isdirty<span class="operator">.</span>isDirty<span class="operator">(</span>lstDiff<span class="operator">);</span>
   qAssert<span class="operator">(</span>bDirty<span class="operator"> &amp;&amp; (</span>lstDiff<span class="operator">.</span>count<span class="operator">() ==</span><span class="int"> 1</span><span class="operator">));</span><span class="flow">
   if</span><span class="operator"> (</span>bDirty<span class="operator">) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] test dirty 2 : container is dirty =&gt; '%s'"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>lstDiff<span class="operator">.</span>join<span class="operator">(</span><span class="string">"|"</span><span class="operator">))); }</span>

   author_ptr_dirty<span class="operator"> =</span> container_isdirty<span class="operator">-&gt;</span>at<span class="operator">(</span><span class="int">2</span><span class="operator">);</span>
   author_ptr_dirty<span class="operator">-&gt;</span>m_birthdate<span class="operator"> =</span> QDate<span class="operator">(</span><span class="int">1998</span><span class="operator">,</span><span class="int"> 03</span><span class="operator">,</span><span class="int"> 06</span><span class="operator">);</span>
   bDirty<span class="operator"> =</span> container_isdirty<span class="operator">.</span>isDirty<span class="operator">(</span>lstDiff<span class="operator">);</span>
   qAssert<span class="operator">(</span>bDirty<span class="operator"> &amp;&amp; (</span>lstDiff<span class="operator">.</span>count<span class="operator">() ==</span><span class="int"> 2</span><span class="operator">));</span><span class="flow">
   if</span><span class="operator"> (</span>bDirty<span class="operator">) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] test dirty 3 : container is dirty =&gt; '%s'"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>lstDiff<span class="operator">.</span>join<span class="operator">(</span><span class="string">"|"</span><span class="operator">))); }</span><span class="comment">

   // Update only property 'm_name' at position 1, only property 'm_birthdate' at position 2 and nothing at position 0
</span>   daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>update_optimized<span class="operator">(</span>container_isdirty<span class="operator">);</span>
   qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">() &amp;&amp; !</span> container_isdirty<span class="operator">.</span>isDirty<span class="operator">());</span>
   qx<span class="operator">::</span>dump<span class="operator">(</span>container_isdirty<span class="operator">);</span><span class="comment">

   // Fetch only property 'm_dt_creation' of blog
</span>   QStringList lstColumns<span class="operator"> =</span> QStringList<span class="operator">() &lt;&lt;</span><span class="string"> "date_creation"</span><span class="operator">;</span>
   list_blog lst_blog_with_only_date_creation<span class="operator">;</span>
   daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_all<span class="operator">(</span>lst_blog_with_only_date_creation<span class="operator">,</span> NULL<span class="operator">,</span> lstColumns<span class="operator">);</span>
   qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">() &amp;&amp; (</span>lst_blog_with_only_date_creation<span class="operator">.</span>size<span class="operator">() &gt;</span><span class="int"> 0</span><span class="operator">));</span><span class="flow">

   if</span><span class="operator"> ((</span>lst_blog_with_only_date_creation<span class="operator">.</span>size<span class="operator">() &gt;</span><span class="int"> 0</span><span class="operator">) &amp;&amp; (</span>lst_blog_with_only_date_creation<span class="operator">[</span><span class="int">0</span><span class="operator">] !=</span> NULL<span class="operator">))
   {</span> qAssert<span class="operator">(</span>lst_blog_with_only_date_creation<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_text<span class="operator">.</span>isEmpty<span class="operator">()); }</span>

   qx<span class="operator">::</span>dump<span class="operator">(</span>lst_blog_with_only_date_creation<span class="operator">);</span></pre>
           </td></tr></tbody></table>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_90"><u><b>Should I use <i>QString</i> or <i>std::string</i> ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           <b>QxOrm</b> advises to use the <a href="http://doc.trolltech.com/4.6/qstring.html" target="_blank"><i>QString</i></a> class for the management of the character strings.<br>
           Even if <b>boost</b> provides many functionalities with its module <a href="http://www.boost.org/doc/libs/1_42_0/doc/html/string_algo.html" target="_blank"><i>boost::string_algo</i></a>, the <i>QString</i> class is easier to use and supports many formats : <i>ASCII, Utf8, Utf16...</i><br>
           However, <b>QxOrm</b> is compatible with <i>std::string</i> and <i>std::wstring</i> if you prefer to use this kind of character strings.
           </td> 
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_95"><u><b>Is it necessary to use <i>smart-pointers</i> ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           <b>QxOrm</b> strongly advises to use <b>boost</b> or <b>Qt</b> <i>smart-pointers</i>.<br>
           The C++ language does not have <i>Garbage Collector</i> like <i>Java</i> or <i>C#</i> for example.<br>
           The use of <i>smart-pointers</i> simplifies the memory management in C++.<br>
           The ideal in a C++ program is not to have any call to <i>delete</i> or <i>delete[]</i>.<br>
           Furthermore, <i>smart-pointer</i> is a new functionality of the new C++ standard : <b>C++1x</b>.<br>
           It is thus essential to know the following classes today : 
           <ul><li><a href="http://www.boost.org/doc/libs/1_42_0/libs/smart_ptr/smart_ptr.htm" target="_blank"><i>shared_ptr</i>, <i>scoped_ptr</i> and <i>weak_ptr</i></a> for the smart pointers of <b>boost</b> library
           </li><li><a href="http://qt.nokia.com/doc/4.6/qsharedpointer.html" target="_blank"><i>QSharedPointer</i>, <i>QScopedPointer</i> and <i>QWeakPointer</i></a> for the smart pointers of <b>Qt</b> library
           </li></ul>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_100"><u><b>The primary key is <i>long</i> type by default. Is it possible to use a key of <i>QString</i> type or other ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           It is possible to define a unique id of <i>QString</i> type or other with <b>QxOrm</b> library.<br> 
           By default, the unique id is <i>long</i> type.<br>
           To indicate that a class has a single identifier of <i>QString</i> type or other, it is necessary to specialize the template <i>qx::trait::get_primary_key</i>.<br>
           To simplify, you can use the macro : <b><i>QX_REGISTER_PRIMARY_KEY(myClass, QString)</i></b>.<br> 
           <br>
           <b>Warning :</b> the macro <b><i>QX_REGISTER_PRIMARY_KEY</i></b> must be used before the macro <b><i>QX_REGISTER_HPP_...</i></b> in the definition of your class, otherwise a compilation error occurs. 
           </td> 
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_101"><u><b>How to define a '<i>multi-columns primary key</i>' (<i>composite key</i>) ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           <b>QxOrm</b> supports '<i>multi-columns primary key</i>'.<br>
           The class id must be defined with following type :<br>
           * <i>QPair</i> or <i>std::pair</i> to define 2 columns<br>
           * <i>boost::tuple</i> to define from 2 columns to 9 columns<br>
           <br>
           It is necessary to use the macro <b><i>QX_REGISTER_PRIMARY_KEY()</i></b> to specialize the template and to map class id with multi-columns in database.<br>
           The list of multi-columns names must be defined with '<b>|</b>' character : '<i>column1|column2|column3|etc...</i>'.<br>
           <br>
           <b>Sample</b> with class '<i>author</i>' from project '<i>qxBlogCompositeKey</i>', this class has an id mapped to 3 columns in database :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _QX_BLOG_AUTHOR_H_
#define _QX_BLOG_AUTHOR_H_
</span><span class="keyword">
class</span> blog<span class="operator">;</span><span class="keyword">

class</span> QX_BLOG_DLL_EXPORT author<span class="operator">
{</span>

   QX_REGISTER_FRIEND_CLASS<span class="operator">(</span>author<span class="operator">)</span><span class="keyword">

public</span><span class="operator">:</span><span class="comment">

// -- composite key (multi-column primary key in database)
</span><span class="keyword">   typedef</span> boost<span class="operator">::</span>tuple<span class="operator">&lt;</span>QString<span class="operator">,</span><span class="type"> long</span><span class="operator">,</span> QString<span class="operator">&gt;</span> type_composite_key<span class="operator">;</span><span class="keyword">
   static</span> QString str_composite_key<span class="operator">() {</span><span class="flow"> return</span><span class="string"> "author_id_0|author_id_1|author_id_2"</span><span class="operator">; }</span><span class="comment">

// -- typedef
</span><span class="keyword">   typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_ptr<span class="operator">;</span><span class="keyword">
   typedef</span> std<span class="operator">::</span>vector<span class="operator">&lt;</span>blog_ptr<span class="operator">&gt;</span> list_blog<span class="operator">;</span><span class="comment">

// -- enum
</span><span class="keyword">   enum</span> enum_sex<span class="operator"> {</span> male<span class="operator">,</span> female<span class="operator">,</span> unknown<span class="operator"> };</span><span class="comment">

// -- properties
</span>   type_composite_key   m_id<span class="operator">;</span>
   QString              m_name<span class="operator">;</span>
   QDate                m_birthdate<span class="operator">;</span>
   enum_sex             m_sex<span class="operator">;</span>
   list_blog            m_blogX<span class="operator">;</span><span class="comment">

// -- contructor, virtual destructor
</span>   author<span class="operator">() :</span> m_id<span class="operator">(</span><span class="string">""</span><span class="operator">,</span><span class="int"> 0</span><span class="operator">,</span><span class="string"> ""</span><span class="operator">),</span> m_sex<span class="operator">(</span>unknown<span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>author<span class="operator">() { ; }</span><span class="comment">

// -- methods
</span><span class="type">   int</span> age<span class="operator">()</span><span class="keyword"> const</span><span class="operator">;</span><span class="comment">

// -- methods "get" to composite key
</span>   type_composite_key getId<span class="operator">()</span><span class="keyword"> const</span><span class="operator">    {</span><span class="flow"> return</span> m_id<span class="operator">; }</span>
   QString getId_0<span class="operator">()</span><span class="keyword"> const</span><span class="operator">             {</span><span class="flow"> return</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">0</span><span class="operator">&gt;(</span>m_id<span class="operator">); }</span><span class="type">
   long</span> getId_1<span class="operator">()</span><span class="keyword"> const</span><span class="operator">                {</span><span class="flow"> return</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">1</span><span class="operator">&gt;(</span>m_id<span class="operator">); }</span>
   QString getId_2<span class="operator">()</span><span class="keyword"> const</span><span class="operator">             {</span><span class="flow"> return</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">2</span><span class="operator">&gt;(</span>m_id<span class="operator">); }</span><span class="comment">

// -- methods "set" to composite key
</span><span class="type">   void</span> setId_0<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> s<span class="operator">)     {</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">0</span><span class="operator">&gt;(</span>m_id<span class="operator">) =</span> s<span class="operator">; }</span><span class="type">
   void</span> setId_1<span class="operator">(</span><span class="type">long</span> l<span class="operator">)                {</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">1</span><span class="operator">&gt;(</span>m_id<span class="operator">) =</span> l<span class="operator">; }</span><span class="type">
   void</span> setId_2<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> s<span class="operator">)     {</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">2</span><span class="operator">&gt;(</span>m_id<span class="operator">) =</span> s<span class="operator">; }

};</span>

QX_REGISTER_PRIMARY_KEY<span class="operator">(</span>author<span class="operator">,</span> author<span class="operator">::</span>type_composite_key<span class="operator">)</span>
QX_REGISTER_HPP_QX_BLOG<span class="operator">(</span>author<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="keyword">

typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>author<span class="operator">&gt;</span> author_ptr<span class="operator">;</span><span class="keyword">
typedef</span> qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span>author<span class="operator">::</span>type_composite_key<span class="operator">,</span> author_ptr<span class="operator">&gt;</span> list_author<span class="operator">;</span><span class="pre">

#endif // _QX_BLOG_AUTHOR_H_
</span></pre>
           </td></tr></tbody></table>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#include "../include/precompiled.h"
#include "../include/author.h"
#include "../include/blog.h"
#include &lt;QxMemLeak.h&gt;
</span>
QX_REGISTER_CPP_QX_BLOG<span class="operator">(</span>author<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>author<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   t<span class="operator">.</span>id<span class="operator">(&amp;</span> author<span class="operator">::</span>m_id<span class="operator">,</span> author<span class="operator">::</span>str_composite_key<span class="operator">());</span>

   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_name<span class="operator">,</span><span class="string"> "name"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_birthdate<span class="operator">,</span><span class="string"> "birthdate"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_sex<span class="operator">,</span><span class="string"> "sex"</span><span class="operator">);</span>

   t<span class="operator">.</span>relationOneToMany<span class="operator">(&amp;</span> author<span class="operator">::</span>m_blogX<span class="operator">,</span> blog<span class="operator">::</span>str_composite_key<span class="operator">(),</span> author<span class="operator">::</span>str_composite_key<span class="operator">());</span>

   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;(&amp;</span> author<span class="operator">::</span>age<span class="operator">,</span><span class="string"> "age"</span><span class="operator">);
}}</span><span class="type">

int</span> author<span class="operator">::</span>age<span class="operator">()</span><span class="keyword"> const</span><span class="operator">
{</span><span class="flow">
   if</span><span class="operator"> (!</span> m_birthdate<span class="operator">.</span>isValid<span class="operator">()) {</span><span class="flow"> return</span><span class="operator"> -</span><span class="int">1</span><span class="operator">; }</span><span class="flow">
   return</span><span class="operator"> (</span>QDate<span class="operator">::</span>currentDate<span class="operator">().</span>year<span class="operator">() -</span> m_birthdate<span class="operator">.</span>year<span class="operator">());
}</span>
</pre>
           </td></tr></tbody></table>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_110"><u><b>How to enable/disable the module <i>QxMemLeak</i> for automatic detection of memory leaks ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           <i>QxMemLeak</i> module provides a fast detection of memory leaks in <i>Debug</i> mode once the execution of the program is finished (with indication of the file and the line =&gt; style MFC from Microsoft).<br>
           This module is developed by <a href="http://wyw.dcweb.cn/leakage.htm" target="_blank">Wu Yongwei</a> and has undergone some modifications to be integrated in <b>QxOrm</b>.<br>
           If another tool is already used in your projects (<i>Valgrind</i> for example), this functionality should not be activated.<br>
           To enable/disable <i>QxMemLeak</i> module, all is needed is to modify the constant <b><i>_QX_USE_MEM_LEAK_DETECTION</i></b> defined in the <i>QxConfig.h.</i> file<i>.</i><br>
           A recompilation of QxOrm library is necessary to take into account this modification.  
           </td> 
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_120"><u><b>How to manage inheritance and database ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           With <i>ORM</i> tools, there is usually 3 strategies to manage inheritance and database :
           <ul>
           <li><i><a href="http://martinfowler.com/eaaCatalog/singleTableInheritance.html" target="_blank">Single Table Inheritance</a></i> ;
           </li><li><i><a href="http://martinfowler.com/eaaCatalog/classTableInheritance.html" target="_blank">Class Table Inheritance</a></i> ;
           </li><li><i><a href="http://martinfowler.com/eaaCatalog/concreteTableInheritance.html" target="_blank">Concrete Table Inheritance</a></i>.
           </li></ul>
           <b>QxOrm</b> works by default with <i>Concrete Table Inheritance</i> strategy (others are not supported yet).<br>
           Many tutorials and forums are available on internet to more details about <i>ORM</i> inheritance and database.<br>
           You can find a sample in the directory <i>./test/qxDllSample/dll2/</i> with the class <i>BaseClassTrigger</i>.
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_130"><u><b>How to define a '<i>Trigger</i>' with QxOrm ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           With <b>QxOrm</b> <i>Trigger</i>, it is possible to execute process before and/or after an insert, update or delete query in the database.<br>
           You can find a sample in the directory <i>./test/qxDllSample/dll2/</i> with the class <i>BaseClassTrigger</i>.<br>
           The class <i>BaseClassTrigger</i> contains 5 properties : <i>m_id</i>, <i>m_dateCreation</i>, <i>m_dateModification</i>, <i>m_userCreation</i> and <i>m_userModification</i>.<br>
           Each property will be automatically auto-updated for all derived classes from <i>BaseClassTrigger</i> (see <i>Foo</i> class and <i>Bar</i> class in the same project).<br>
           It is necessary to specialize '<i>QxDao_Trigger</i>' template to work with this feature.<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _QX_BASE_CLASS_TRIGGER_H_
#define _QX_BASE_CLASS_TRIGGER_H_
</span><span class="keyword">
class</span> QX_DLL2_EXPORT BaseClassTrigger<span class="operator">
{</span>

   QX_REGISTER_FRIEND_CLASS<span class="operator">(</span>BaseClassTrigger<span class="operator">)</span><span class="keyword">

protected</span><span class="operator">:</span><span class="type">

   long</span>        m_id<span class="operator">;</span>
   QDateTime   m_dateCreation<span class="operator">;</span>
   QDateTime   m_dateModification<span class="operator">;</span>
   QString     m_userCreation<span class="operator">;</span>
   QString     m_userModification<span class="operator">;</span><span class="keyword">

public</span><span class="operator">:</span>

   BaseClassTrigger<span class="operator">() :</span> m_id<span class="operator">(</span><span class="int">0</span><span class="operator">)  { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>BaseClassTrigger<span class="operator">()   { ; }</span><span class="type">

   long</span> getId<span class="operator">()</span><span class="keyword"> const</span><span class="operator">                     {</span><span class="flow"> return</span> m_id<span class="operator">; }</span>
   QDateTime getDateCreation<span class="operator">()</span><span class="keyword"> const</span><span class="operator">      {</span><span class="flow"> return</span> m_dateCreation<span class="operator">; }</span>
   QDateTime getDateModification<span class="operator">()</span><span class="keyword"> const</span><span class="operator">  {</span><span class="flow"> return</span> m_dateModification<span class="operator">; }</span>
   QString getUserCreation<span class="operator">()</span><span class="keyword"> const</span><span class="operator">        {</span><span class="flow"> return</span> m_userCreation<span class="operator">; }</span>
   QString getUserModification<span class="operator">()</span><span class="keyword"> const</span><span class="operator">    {</span><span class="flow"> return</span> m_userModification<span class="operator">; }</span><span class="type">

   void</span> setId<span class="operator">(</span><span class="type">long</span> l<span class="operator">)                              {</span> m_id<span class="operator"> =</span> l<span class="operator">; }</span><span class="type">
   void</span> setDateCreation<span class="operator">(</span><span class="keyword">const</span> QDateTime<span class="operator"> &amp;</span> dt<span class="operator">)      {</span> m_dateCreation<span class="operator"> =</span> dt<span class="operator">; }</span><span class="type">
   void</span> setDateModification<span class="operator">(</span><span class="keyword">const</span> QDateTime<span class="operator"> &amp;</span> dt<span class="operator">)  {</span> m_dateModification<span class="operator"> =</span> dt<span class="operator">; }</span><span class="type">
   void</span> setUserCreation<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> s<span class="operator">)         {</span> m_userCreation<span class="operator"> =</span> s<span class="operator">; }</span><span class="type">
   void</span> setUserModification<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> s<span class="operator">)     {</span> m_userModification<span class="operator"> =</span> s<span class="operator">; }</span><span class="type">

   void</span> onBeforeInsert<span class="operator">(</span>qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">);</span><span class="type">
   void</span> onBeforeUpdate<span class="operator">(</span>qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">);

};</span>

QX_REGISTER_HPP_QX_DLL2<span class="operator">(</span>BaseClassTrigger<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
namespace</span> dao<span class="operator"> {</span><span class="keyword">
namespace</span> detail<span class="operator"> {</span><span class="keyword">

template</span><span class="operator"> &lt;&gt;</span><span class="keyword">
struct</span> QxDao_Trigger<span class="operator">&lt;</span>BaseClassTrigger<span class="operator">&gt;
{</span><span class="keyword">

   static inline</span><span class="type"> void</span> onBeforeInsert<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span><span class="flow"> if</span><span class="operator"> (</span>t<span class="operator">) {</span> t<span class="operator">-&gt;</span>onBeforeInsert<span class="operator">(</span>dao<span class="operator">); } }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onBeforeUpdate<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span><span class="flow"> if</span><span class="operator"> (</span>t<span class="operator">) {</span> t<span class="operator">-&gt;</span>onBeforeUpdate<span class="operator">(</span>dao<span class="operator">); } }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onBeforeDelete<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onAfterInsert<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onAfterUpdate<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onAfterDelete<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }

};

}</span><span class="comment"> // namespace detail
</span><span class="operator">}</span><span class="comment"> // namespace dao
</span><span class="operator">}</span><span class="comment"> // namespace qx
</span><span class="pre">
#endif // _QX_BASE_CLASS_TRIGGER_H_
</span></pre>
           </td></tr></tbody></table>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#include "../include/precompiled.h"
#include "../include/BaseClassTrigger.h"
#include &lt;QxMemLeak.h&gt;
</span>
QX_REGISTER_CPP_QX_DLL2<span class="operator">(</span>BaseClassTrigger<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>BaseClassTrigger<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   IxDataMember<span class="operator"> *</span> pData<span class="operator"> =</span> NULL<span class="operator">;</span>

   pData<span class="operator"> =</span> t<span class="operator">.</span>id<span class="operator">(&amp;</span> BaseClassTrigger<span class="operator">::</span>m_id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>

   pData<span class="operator"> =</span> t<span class="operator">.</span>data<span class="operator">(&amp;</span> BaseClassTrigger<span class="operator">::</span>m_dateCreation<span class="operator">,</span><span class="string"> "date_creation"</span><span class="operator">);</span>
   pData<span class="operator"> =</span> t<span class="operator">.</span>data<span class="operator">(&amp;</span> BaseClassTrigger<span class="operator">::</span>m_dateModification<span class="operator">,</span><span class="string"> "date_modification"</span><span class="operator">);</span>
   pData<span class="operator"> =</span> t<span class="operator">.</span>data<span class="operator">(&amp;</span> BaseClassTrigger<span class="operator">::</span>m_userCreation<span class="operator">,</span><span class="string"> "user_creation"</span><span class="operator">);</span>
   pData<span class="operator"> =</span> t<span class="operator">.</span>data<span class="operator">(&amp;</span> BaseClassTrigger<span class="operator">::</span>m_userModification<span class="operator">,</span><span class="string"> "user_modification"</span><span class="operator">);
}}</span><span class="type">

void</span> BaseClassTrigger<span class="operator">::</span>onBeforeInsert<span class="operator">(</span>qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
{</span>
   Q_UNUSED<span class="operator">(</span>dao<span class="operator">);</span>
   m_dateCreation<span class="operator"> =</span> QDateTime<span class="operator">::</span>currentDateTime<span class="operator">();</span>
   m_dateModification<span class="operator"> =</span> QDateTime<span class="operator">::</span>currentDateTime<span class="operator">();</span>
   m_userCreation<span class="operator"> =</span><span class="string"> "current_user_1"</span><span class="operator">;</span>
   m_userModification<span class="operator"> =</span><span class="string"> "current_user_1"</span><span class="operator">;
}</span><span class="type">

void</span> BaseClassTrigger<span class="operator">::</span>onBeforeUpdate<span class="operator">(</span>qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
{</span>
   Q_UNUSED<span class="operator">(</span>dao<span class="operator">);</span>
   m_dateModification<span class="operator"> =</span> QDateTime<span class="operator">::</span>currentDateTime<span class="operator">();</span>
   m_userModification<span class="operator"> =</span><span class="string"> "current_user_2"</span><span class="operator">;
}</span>
</pre>
           </td></tr></tbody></table>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_140"><u><b>How to register an abstract class into QxOrm context ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           A C++ abstract class (with at least one pure virtual method) cannot be mapped to a table of a database (because it cannot be instantiated).<br>
           However, in some case, it can be interesting to define properties into abstract class used by a persistent object (by inheritance).<br>
           A sample of abstract class registered into QxOrm context is available in the directory <i>./test/qxDllSample/dll2/</i> of QxOrm package with the class <i>BaseClassTrigger</i>.<br>
           To register an abstract class into QxOrm context, you have to :
           <ul>
           <li>register the class with '<i>void register_class</i>' like any other class ;
           </li><li>use macro <b>QX_REGISTER_ABSTRACT_CLASS(className)</b> just after the class definition.
           </li></ul>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_150"><u><b>How to register a class defined into a namespace into QxOrm context ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           If a class is defined into a namespace, a compilation error occurs using macros : <b>QX_REGISTER_HPP</b> and <b>QX_REGISTER_CPP</b>.<br>
           To avoid this compilation error, it is necessary to use followings macros : <b>QX_REGISTER_COMPLEX_CLASS_NAME_HPP</b> and <b>QX_REGISTER_COMPLEX_CLASS_NAME_CPP</b>.<br>
           You can find a sample in the directory <i>./test/qxDllSample/dll1/</i> of QxOrm package with the class <i>CPerson</i> defined into namespace <i>qx::test</i> :<br>
           <br>
           * <i><b>QX_REGISTER_COMPLEX_CLASS_NAME_HPP_QX_DLL1(qx::test::CPerson, QObject, 0, qx_test_CPerson)</b></i>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_160"><u><b>How to define a soft delete behavior ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           A soft delete doesn't remove rows from database (this is not a physical delete) : a new column is added to the table definition to flag a row as deleted or not.<br>
           This column can contain a boolean (1 means row deleted, 0 or NULL means row not deleted), or can contain deletion date-time (if empty or NULL, row is not deleted).<br>
           So you can reactivate a deleted row by setting NULL or empty value into database.<br>
           <br>
           To define a soft delete behavior with QxOrm library, you have to use the class <b>qx::QxSoftDelete</b> in function mapping by class <i>qx::register_class&lt;T&gt;</i>.<br>
           Here is an example with the class <i>Bar</i> containing 2 properties <i>m_id</i> and <i>m_desc</i> :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>Bar<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   t<span class="operator">.</span>setSoftDelete<span class="operator">(</span>qx<span class="operator">::</span>QxSoftDelete<span class="operator">(</span><span class="string">"deleted_at"</span><span class="operator">));</span>

   t<span class="operator">.</span>id<span class="operator">(&amp;</span> Bar<span class="operator">::</span>m_id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> Bar<span class="operator">::</span>m_desc<span class="operator">,</span><span class="string"> "desc"</span><span class="operator">);
}}</span></pre>
           </td></tr></tbody></table>
           <br>
           SQL queries builded by QxOrm library will take into account this soft delete parameter to add conditions (don't fetch deleted item, don't delete physically a row, etc.).<br>
           For example, if you execute this code with the class <i>Bar</i> :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>Bar_ptr pBar<span class="operator">;</span> pBar<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> Bar<span class="operator">());</span>
pBar<span class="operator">-&gt;</span>setId<span class="operator">(</span><span class="int">5</span><span class="operator">);</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>delete_by_id<span class="operator">(</span>pBar<span class="operator">);</span>     qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">());</span>
qx_bool bDaoExist<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>exist<span class="operator">(</span>pBar<span class="operator">);</span>             qAssert<span class="operator">(!</span> bDaoExist<span class="operator">);</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>delete_all<span class="operator">&lt;</span>Bar<span class="operator">&gt;();</span>                qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">());</span><span class="type">
long</span> lBarCount<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>count<span class="operator">&lt;</span>Bar<span class="operator">&gt;();</span>               qAssert<span class="operator">(</span>lBarCount<span class="operator"> ==</span><span class="int"> 0</span><span class="operator">);</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>destroy_all<span class="operator">&lt;</span>Bar<span class="operator">&gt;();</span>               qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">());</span></pre>
           </td></tr></tbody></table>
           <br>
           You will obtain following output trace :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="operator">[</span>QxOrm<span class="operator">]</span> sql query<span class="operator"> (</span><span class="int">93</span> ms<span class="operator">) :</span> UPDATE Bar SET deleted_at<span class="operator"> =</span><span class="char"> '20110617115148615'</span> WHERE id<span class="operator"> = :</span>id<span class="operator">
[</span>QxOrm<span class="operator">]</span> sql query<span class="operator"> (</span><span class="int">0</span> ms<span class="operator">) :</span> SELECT Bar<span class="operator">.</span>id AS Bar_id_0<span class="operator">,</span> Bar<span class="operator">.</span>deleted_at FROM Bar WHERE Bar<span class="operator">.</span>id<span class="operator"> = :</span>id AND<span class="operator"> (</span>Bar<span class="operator">.</span>deleted_at IS NULL OR Bar<span class="operator">.</span>deleted_at<span class="operator"> =</span><span class="char"> ''</span><span class="operator">)
[</span>QxOrm<span class="operator">]</span> sql query<span class="operator"> (</span><span class="int">78</span> ms<span class="operator">) :</span> UPDATE Bar SET deleted_at<span class="operator"> =</span><span class="char"> '20110617115148724'</span><span class="operator">
[</span>QxOrm<span class="operator">]</span> sql query<span class="operator"> (</span><span class="int">0</span> ms<span class="operator">) :</span> SELECT COUNT<span class="operator">(*)</span> FROM Bar WHERE<span class="operator"> (</span>Bar<span class="operator">.</span>deleted_at IS NULL OR Bar<span class="operator">.</span>deleted_at<span class="operator"> =</span><span class="char"> ''</span><span class="operator">)
[</span>QxOrm<span class="operator">]</span> sql query<span class="operator"> (</span><span class="int">110</span> ms<span class="operator">) :</span> DELETE FROM Bar</pre>
           </td></tr></tbody></table>
           <br>
           <b>Note :</b> to delete physically a row from database, you have to use followings functions : <i>qx::dao::destroy_by_id()</i> and <i>qx::dao::destroy_all()</i>.<br>
           <br>
           <b>Other note :</b> it is recommended to define into database an index on column <i>deleted_at</i> to optimize execution of SQL queries.<br>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_170"><u><b>How to use a session (<i>qx::QxSession</i> class) to manage automatically database transactions (using C++ RAII) ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
            <a href="http://en.wikipedia.org/wiki/Database_transaction" target="_blank">A database <b>transaction</b></a> is a sequence of operations performed as a single logical unit of work.<br>
            If no errors occurred during the execution of the transaction then the system <b>commits</b> the transaction.<br>
            If an error occurs during the transaction, or if the user specifies a <b>rollback</b> operation, the data manipulations within the transaction are not persisted to the database.<br>
            <br>
            The <b>qx::QxSession</b> class of QxOrm library is designed to manage automatically database transactions (using <a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization" target="_blank">C++ RAII</a>) :<br>
            <br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="operator">{</span><span class="comment"> // Start a scope where a new session is instantiated

  // Create a session : a valid database connexion by thread is automatically assigned to the session and a transaction is opened
  </span>qx<span class="operator">::</span>QxSession session<span class="operator">;</span><span class="comment">

  // Execute some operations with database (using += operator of qx::QxSession class and session database connexion)
  </span>session<span class="operator"> +=</span> qx<span class="operator">::</span>dao<span class="operator">::</span>insert<span class="operator">(</span>my_object<span class="operator">,</span> session<span class="operator">.</span>database<span class="operator">());</span>
  session<span class="operator"> +=</span> qx<span class="operator">::</span>dao<span class="operator">::</span>update<span class="operator">(</span>my_object<span class="operator">,</span> session<span class="operator">.</span>database<span class="operator">());</span>
  session<span class="operator"> +=</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id<span class="operator">(</span>my_object<span class="operator">,</span> session<span class="operator">.</span>database<span class="operator">());</span>
  session<span class="operator"> +=</span> qx<span class="operator">::</span>dao<span class="operator">::</span>delete_by_id<span class="operator">(</span>my_object<span class="operator">,</span> session<span class="operator">.</span>database<span class="operator">());</span><span class="comment">

  // If the session is not valid (so an error occured) =&gt; display first error
  </span><span class="flow">if</span><span class="operator"> (!</span> session<span class="operator">.</span>isValid<span class="operator">()) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] session error : '%s'"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>session<span class="operator">.</span>firstError<span class="operator">().</span>text<span class="operator">())); }

}</span><span class="comment"> // End of scope : session is destroyed (transaction =&gt; automatically commit or rollback if there is an error)</span></pre>
            </td></tr></tbody></table>
            <br>
            <b>Note :</b> a session can throw a <i>qx::dao::sql_error</i> exception when a SQL error occured (by default, there is no exception). You can setup this feature using :<br>
            * <i>qx::QxSession</i> constructor (for a specific session) ;<br>
            * <i>qx::QxSqlDatabase::getSingleton()->setSessionThrowable(bool b)</i> parameter (for all sessions).<br>
            <br>
            <b>Other note :</b> don't forget to pass the session database connexion to each <i>qx::dao::xxx</i> functions (using <i>session.database()</i> method).<br>
            Moreover, you can manage your own database connexion (from a connexion pool for example) using constructor of <i>qx::QxSession</i> class.<br>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_180"><u><b>How to persist a type without its source code (class from an external library for example) ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           QxOrm library can persist every types, not only classes registered into QxOrm context using <i>qx::register_class&lt;T&gt;()</i>.<br>
           <br>
           It's necessary to write serialization functions from boost framework, using the <b>non intrusive</b> method (because source code is not available or is read-only).
           For more details on boost serialization module, <a href="http://www.boost.org/doc/libs/1_47_0/libs/serialization/doc/index.html" target="_blank">goto official website</a>.<br>
           <br>
           For example, imagine that you have the class '<i>ExtObject3D</i>' from an external library and the source code is not available or is read-only.
           Here is the code to can persist an instance of '<i>ExtObject3D</i>' type into database :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _PERSIST_EXTOBJECT3D_H_
#define _PERSIST_EXTOBJECT3D_H_

#include "ExtObject3D.h"

#include &lt;boost/serialization/serialization.hpp&gt;
#include &lt;boost/serialization/split_free.hpp&gt;
#include &lt;boost/serialization/nvp.hpp&gt;
</span><span class="keyword"> 
namespace</span> boost<span class="operator"> {</span><span class="keyword">
namespace</span> serialization<span class="operator"> {</span><span class="keyword">

template</span><span class="operator"> &lt;</span><span class="keyword">class</span> Archive<span class="operator">&gt;</span><span class="type">
void</span> save<span class="operator">(</span>Archive<span class="operator"> &amp;</span> ar<span class="operator">,</span><span class="keyword"> const</span> ExtObject3D<span class="operator"> &amp;</span> t<span class="operator">,</span><span class="type"> unsigned int</span> version<span class="operator">)
{</span>
   Q_UNUSED<span class="operator">(</span>version<span class="operator">);</span><span class="type">
   double</span> x<span class="operator">(</span>t<span class="operator">.</span>getX<span class="operator">()),</span> y<span class="operator">(</span>t<span class="operator">.</span>getY<span class="operator">()),</span> z<span class="operator">(</span>t<span class="operator">.</span>getZ<span class="operator">()),</span> angle<span class="operator">(</span>t<span class="operator">.</span>getAngle<span class="operator">());</span>

   ar<span class="operator"> &lt;&lt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"x"</span><span class="operator">,</span> x<span class="operator">);</span>
   ar<span class="operator"> &lt;&lt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"y"</span><span class="operator">,</span> y<span class="operator">);</span>
   ar<span class="operator"> &lt;&lt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"z"</span><span class="operator">,</span> z<span class="operator">);</span>
   ar<span class="operator"> &lt;&lt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"angle"</span><span class="operator">,</span> angle<span class="operator">);
}</span><span class="keyword">

template</span><span class="operator"> &lt;</span><span class="keyword">class</span> Archive<span class="operator">&gt;</span><span class="type">
void</span> load<span class="operator">(</span>Archive<span class="operator"> &amp;</span> ar<span class="operator">,</span> ExtObject3D<span class="operator"> &amp;</span> t<span class="operator">,</span><span class="type"> unsigned int</span> version<span class="operator">)
{</span>
   Q_UNUSED<span class="operator">(</span>version<span class="operator">);</span><span class="type">
   double</span> x<span class="operator">(</span><span class="float">0.0</span><span class="operator">),</span> y<span class="operator">(</span><span class="float">0.0</span><span class="operator">),</span> z<span class="operator">(</span><span class="float">0.0</span><span class="operator">),</span> angle<span class="operator">(</span><span class="float">0.0</span><span class="operator">);</span>

   ar<span class="operator"> &gt;&gt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"x"</span><span class="operator">,</span> x<span class="operator">);</span>
   ar<span class="operator"> &gt;&gt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"y"</span><span class="operator">,</span> y<span class="operator">);</span>
   ar<span class="operator"> &gt;&gt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"z"</span><span class="operator">,</span> z<span class="operator">);</span>
   ar<span class="operator"> &gt;&gt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"angle"</span><span class="operator">,</span> angle<span class="operator">);</span>

   t<span class="operator">.</span>setX<span class="operator">(</span>x<span class="operator">);</span>
   t<span class="operator">.</span>setY<span class="operator">(</span>y<span class="operator">);</span>
   t<span class="operator">.</span>setZ<span class="operator">(</span>z<span class="operator">);</span>
   t<span class="operator">.</span>setAngle<span class="operator">(</span>angle<span class="operator">);
}

}</span><span class="comment"> // namespace serialization
</span><span class="operator">}</span><span class="comment"> // namespace boost
</span> 
BOOST_SERIALIZATION_SPLIT_FREE<span class="operator">(</span>ExtObject3D<span class="operator">)</span><span class="pre">

#endif // _PERSIST_EXTOBJECT3D_H_</span></pre>
           </td></tr></tbody></table>
           <br>
           Now you can persist an instance of '<i>ExtObject3D</i>' type into database : so you can have a '<i>ExtObject3D</i>' property in a persistent class registered into QxOrm context.
           This property can be mapped with a column of type <i>TEXT</i> or <i>VARCHAR</i> into database.<br>
           <br>
           The default behaviour of QxOrm library is : the instance is serialized to XML format before to be inserted or updated into database.
           This default behaviour can be useful, for example if you want to save a collection of items without to make relation (so you don't have to manage another table into database).
           For example, with a property of type <i>std::vector&lt;mon_objet&gt;</i> in a persistent class without relation, the list of items will be saved into database under XML format.<br>
           <br>
           <b>Note :</b> the default behaviour can be easily modified for a specific type.
           <i>QtSql</i> engine uses <i>QVariant</i> type to link C++ code and database.
           <i>QVariant</i> type can contain text, numeric, binary, etc.
           So it can be interesting to specialize the default behaviour (XML serialization) if you want to save datas under binary format or to optimize your application (XML serialization is not very fast).
           You just have to write (with boost serialization functions) a conversion into/from <i>QVariant</i> type, for example with '<i>ExtObject3D</i>' class :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
namespace</span> cvt<span class="operator"> {</span><span class="keyword">
namespace</span> detail<span class="operator"> {</span><span class="keyword">

template</span><span class="operator"> &lt;&gt;</span><span class="keyword"> struct</span> QxStringCvt_ToVariant<span class="operator">&lt;</span> ExtObject3D<span class="operator"> &gt; {</span><span class="keyword">
static inline</span> QVariant toVariant<span class="operator">(</span><span class="keyword">const</span> ExtObject3D<span class="operator"> &amp;</span> t<span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> format<span class="operator">,</span><span class="type"> int</span> index<span class="operator">)
{</span><span class="comment"> /* Ici je convertis ExtObject3D en QVariant */</span><span class="operator"> } };</span><span class="keyword">

template</span><span class="operator"> &lt;&gt;</span><span class="keyword"> struct</span> QxStringCvt_FromVariant<span class="operator">&lt;</span> ExtObject3D<span class="operator"> &gt; {</span><span class="keyword">
static inline</span> qx_bool fromVariant<span class="operator">(</span><span class="keyword">const</span> QVariant<span class="operator"> &amp;</span> v<span class="operator">,</span> ExtObject3D<span class="operator"> &amp;</span> t<span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> format<span class="operator">,</span><span class="type"> int</span> index<span class="operator">)
{</span><span class="comment"> /* Ici je convertis QVariant en ExtObject3D */</span><span class="operator">;</span><span class="flow"> return</span> qx_bool<span class="operator">(</span><span class="bool">true</span><span class="operator">); } };

}</span><span class="comment"> // namespace detail
</span><span class="operator">}</span><span class="comment"> // namespace cvt
</span><span class="operator">}</span><span class="comment"> // namespace qx</span></pre>
           </td></tr></tbody></table>
           <br>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_190"><u><b>How to use introspection engine (or reflection engine) of QxOrm library ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           All classes registered into QxOrm context using <i>qx::register_class&lt;T&gt;()</i> function can be used by introspection engine (or reflection engine) of QxOrm library.
           Introspection engine can provide dynamically (so during program execution) some informations about types.
           Those informations are called <i>meta-datas</i> and can list all classes characteristics (properties, methods, etc.).
           Many programming languages (for example Java or C#) have natively this mechanism, but not C++, that's why QxOrm library emulates an introspection engine.<br>
           <br>
           Here is a list of QxOrm library classes to access to <i>meta-datas</i> :
           <ul>
             <li><a href="../doxygen/html/classqx_1_1_qx_class_x.html" target="_blank">qx::QxClassX</a> : singleton class to iterate over all classes registered into QxOrm context using <i>qx::register_class&lt;T&gt;()</i> ;</li>
             <li><a href="../doxygen/html/classqx_1_1_ix_class.html" target="_blank">qx::IxClass</a> : interface for a class registered into QxOrm context ;</li>
             <li><a href="../doxygen/html/classqx_1_1_ix_data_member_x.html" target="_blank">qx::IxDataMemberX</a> : list of properties associated to a class ;</li>
             <li><a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a> : interface for a class property ;</li>
             <li><a href="../doxygen/html/classqx_1_1_ix_function.html" target="_blank">qx::IxFunctionX</a> : list of methods associated to a class ;</li>
             <li><a href="../doxygen/html/classqx_1_1_ix_function.html" target="_blank">qx::IxFunction</a> : interface for a class method.</li>
           </ul>
           An instance of <i>qx::IxClass</i> type contains the list of class properties (<i>qx::IxDataMemberX</i>) and the list of class methods (<i>qx::IxFunctionX</i>).<br>
           <br>
           Introspection engine of QxOrm library provides :
           <ul>
             <li>to create dynamically an instance of a class using class name under string format (<i>qx::create()</i>) ;</li>
             <li>to access/modify dynamically the value of an object field (<i>qx::IxDataMember::getValue()</i> and <i>qx::IxDataMember::setValue()</i>) ;</li>
             <li>to invoke dynamically a class method (<i>qx::IxFunction::invoke()</i>) ;</li>
             <li>to access to the class hierarchy (<i>qx::IxClass::getBaseClass()</i>).</li>
           </ul>
           <b>Note :</b> <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a> module of QxOrm library (<a href="./tutorial_2.html" target="_blank">click here to go to the tutorial</a>) to create easily a C++ application server is based on introspection engine to call dynamically services methods (client request) on server side.<br>
           <br>
           Here is a sample using introspection engine : how to dump all classes, properties and methods registered into QxOrm context ?<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QString QxClassX<span class="operator">::</span>dumpAllClasses<span class="operator">()
{</span>
   QxClassX<span class="operator">::</span>registerAllClasses<span class="operator">();</span>
   QxCollection<span class="operator">&lt;</span>QString<span class="operator">,</span> IxClass<span class="operator"> *&gt; *</span> pAllClasses<span class="operator"> =</span> QxClassX<span class="operator">::</span>getAllClasses<span class="operator">();</span><span class="flow">
   if</span><span class="operator"> (!</span> pAllClasses<span class="operator">) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span><span class="string"> ""</span><span class="operator">; }</span>

   QString sDump<span class="operator">;</span><span class="type">
   long</span> lCount<span class="operator"> =</span> pAllClasses<span class="operator">-&gt;</span>count<span class="operator">();</span>
   qDebug<span class="operator">(</span><span class="string">"[QxOrm] start dump all registered classes (%ld)"</span><span class="operator">,</span> lCount<span class="operator">);</span>
   _foreach<span class="operator">(</span>IxClass<span class="operator"> *</span> pClass<span class="operator">, (*</span> pAllClasses<span class="operator">))
   {</span><span class="flow"> if</span><span class="operator"> (</span>pClass<span class="operator">) {</span> sDump<span class="operator"> +=</span> pClass<span class="operator">-&gt;</span>dumpClass<span class="operator">(); } }</span>
   qDebug<span class="operator">(</span><span class="string">"[QxOrm] %s"</span><span class="operator">,</span><span class="string"> "end dump all registered classes"</span><span class="operator">);</span><span class="flow">

   return</span> sDump<span class="operator">;
}</span>

QString IxClass<span class="operator">::</span>dumpClass<span class="operator">()</span><span class="keyword"> const</span><span class="operator">
{</span>
   QString sDump<span class="operator">;</span>
   sDump<span class="operator"> +=</span><span class="string"> "-- class '"</span><span class="operator"> +</span> m_sKey<span class="operator"> +</span><span class="string"> "' (name '"</span><span class="operator"> +</span> m_sName<span class="operator"> +</span><span class="string"> "', "</span><span class="operator">;</span>
   sDump<span class="operator"> +=</span><span class="string"> "description '"</span><span class="operator"> +</span> m_sDescription<span class="operator"> +</span><span class="string"> "', version '"</span><span class="operator"> +</span> QString<span class="operator">::</span>number<span class="operator">(</span>m_lVersion<span class="operator">) +</span><span class="string"> "', "</span><span class="operator">;</span>
   sDump<span class="operator"> +=</span><span class="string"> "base class '"</span><span class="operator"> + (</span>getBaseClass<span class="operator">() ?</span> getBaseClass<span class="operator">()-&gt;</span>getKey<span class="operator">() :</span><span class="string"> ""</span><span class="operator">) +</span><span class="string"> "')\n"</span><span class="operator">;</span><span class="type">

   long</span> lCount<span class="operator"> = (</span>m_pDataMemberX<span class="operator"> ?</span> m_pDataMemberX<span class="operator">-&gt;</span>count<span class="operator">() :</span><span class="int"> 0</span><span class="operator">);</span>
   sDump<span class="operator"> +=</span><span class="string"> "\t* list of registered properties ("</span><span class="operator"> +</span> QString<span class="operator">::</span>number<span class="operator">(</span>lCount<span class="operator">) +</span><span class="string"> ")\n"</span><span class="operator">;</span><span class="flow">
   if</span><span class="operator"> (</span>m_pDataMemberX<span class="operator">)
   {</span>
      IxDataMember<span class="operator"> *</span> pId<span class="operator"> =</span><span class="keyword"> this</span><span class="operator">-&gt;</span>getId<span class="operator">();</span><span class="flow">
      for</span><span class="operator"> (</span><span class="type">long</span> l<span class="operator"> =</span><span class="int"> 0</span><span class="operator">;</span> l<span class="operator"> &lt;</span> lCount<span class="operator">;</span> l<span class="operator">++)
      {</span>
         IxDataMember<span class="operator"> *</span> p<span class="operator"> =</span> m_pDataMemberX<span class="operator">-&gt;</span>get<span class="operator">(</span>l<span class="operator">);</span><span class="flow"> if</span><span class="operator"> (!</span> p<span class="operator">) {</span><span class="flow"> continue</span><span class="operator">; }</span>
         IxSqlRelation<span class="operator"> *</span> pRelation<span class="operator"> =</span> p<span class="operator">-&gt;</span>getSqlRelation<span class="operator">();</span>
         QString sInfos<span class="operator"> =</span> p<span class="operator">-&gt;</span>getKey<span class="operator">() + ((</span>p<span class="operator"> ==</span> pId<span class="operator">) ?</span> QString<span class="operator">(</span><span class="string">" (id)"</span><span class="operator">) :</span> QString<span class="operator">());</span>
         sInfos<span class="operator"> += (</span>pRelation<span class="operator"> ? (</span>QString<span class="operator">(</span><span class="string">" ("</span><span class="operator">) +</span> pRelation<span class="operator">-&gt;</span>getDescription<span class="operator">() +</span> QString<span class="operator">(</span><span class="string">")"</span><span class="operator">)) :</span> QString<span class="operator">());</span>
         sDump<span class="operator"> +=</span><span class="string"> "\t\t"</span><span class="operator"> +</span> sInfos<span class="operator"> +</span><span class="string"> "\n"</span><span class="operator">;
      }
   }</span>

   lCount<span class="operator"> = (</span>m_pFctMemberX<span class="operator"> ?</span> m_pFctMemberX<span class="operator">-&gt;</span>count<span class="operator">() :</span><span class="int"> 0</span><span class="operator">);</span>
   sDump<span class="operator"> +=</span><span class="string"> "\t* list of registered functions ("</span><span class="operator"> +</span> QString<span class="operator">::</span>number<span class="operator">(</span>lCount<span class="operator">) +</span><span class="string"> ")\n"</span><span class="operator">;</span><span class="flow">
   if</span><span class="operator"> (</span>m_pFctMemberX<span class="operator">)
   {</span>
      _foreach_if<span class="operator">(</span>IxFunction_ptr p<span class="operator">, (*</span> m_pFctMemberX<span class="operator">), (</span>p<span class="operator">))
      {</span> QString sKey<span class="operator"> =</span> p<span class="operator">-&gt;</span>getKey<span class="operator">();</span> sDump<span class="operator"> +=</span><span class="string"> "\t\t"</span><span class="operator"> +</span> sKey<span class="operator"> +</span><span class="string"> "\n"</span><span class="operator">; }
   }</span>

   qDebug<span class="operator">(</span><span class="string">"%s"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>sDump<span class="operator">));</span><span class="flow">
   return</span> sDump<span class="operator">;
}</span></pre>
           </td></tr></tbody></table>
           <br>
           Using the function <i>qx::QxClassX::dumpAllClasses()</i> with <a href="./tutorial.html" target="_blank">qxBlog tutorial</a>, you will obtain following output :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="operator">[</span>QxOrm<span class="operator">]</span> start dump all registered classes<span class="operator"> (</span><span class="int">4</span><span class="operator">)
--</span><span class="keyword"> class</span><span class="char"> 'author'</span><span class="operator"> (</span>name<span class="char"> 'author'</span><span class="operator">,</span> description<span class="char"> ''</span><span class="operator">,</span> version<span class="char"> '0'</span><span class="operator">,</span> base<span class="keyword"> class</span><span class="char"> ''</span><span class="operator">)
	*</span> list of registered properties<span class="operator"> (</span><span class="int">5</span><span class="operator">)</span>
		author_id<span class="operator"> (</span>id<span class="operator">)</span>
		name
		birthdate
		sex
		list_blog<span class="operator"> (</span>relation one<span class="operator">-</span>to<span class="operator">-</span>many<span class="operator">)
	*</span> list of registered functions<span class="operator"> (</span><span class="int">1</span><span class="operator">)</span>
		age<span class="operator">

--</span><span class="keyword"> class</span><span class="char"> 'blog'</span><span class="operator"> (</span>name<span class="char"> 'blog'</span><span class="operator">,</span> description<span class="char"> ''</span><span class="operator">,</span> version<span class="char"> '0'</span><span class="operator">,</span> base<span class="keyword"> class</span><span class="char"> ''</span><span class="operator">)
	*</span> list of registered properties<span class="operator"> (</span><span class="int">6</span><span class="operator">)</span>
		blog_id<span class="operator"> (</span>id<span class="operator">)</span>
		blog_text
		date_creation
		author_id<span class="operator"> (</span>relation many<span class="operator">-</span>to<span class="operator">-</span>one<span class="operator">)</span>
		list_comment<span class="operator"> (</span>relation one<span class="operator">-</span>to<span class="operator">-</span>many<span class="operator">)</span>
		list_category<span class="operator"> (</span>relation many<span class="operator">-</span>to<span class="operator">-</span>many<span class="operator">)
	*</span> list of registered functions<span class="operator"> (</span><span class="int">0</span><span class="operator">)

--</span><span class="keyword"> class</span><span class="char"> 'comment'</span><span class="operator"> (</span>name<span class="char"> 'comment'</span><span class="operator">,</span> description<span class="char"> ''</span><span class="operator">,</span> version<span class="char"> '0'</span><span class="operator">,</span> base<span class="keyword"> class</span><span class="char"> ''</span><span class="operator">)
	*</span> list of registered properties<span class="operator"> (</span><span class="int">4</span><span class="operator">)</span>
		comment_id<span class="operator"> (</span>id<span class="operator">)</span>
		comment_text
		date_creation
		blog_id<span class="operator"> (</span>relation many<span class="operator">-</span>to<span class="operator">-</span>one<span class="operator">)
	*</span> list of registered functions<span class="operator"> (</span><span class="int">0</span><span class="operator">)

--</span><span class="keyword"> class</span><span class="char"> 'category'</span><span class="operator"> (</span>name<span class="char"> 'category'</span><span class="operator">,</span> description<span class="char"> ''</span><span class="operator">,</span> version<span class="char"> '0'</span><span class="operator">,</span> base<span class="keyword"> class</span><span class="char"> ''</span><span class="operator">)
	*</span> list of registered properties<span class="operator"> (</span><span class="int">4</span><span class="operator">)</span>
		category_id<span class="operator"> (</span>id<span class="operator">)</span>
		name
		description
		list_blog<span class="operator"> (</span>relation many<span class="operator">-</span>to<span class="operator">-</span>many<span class="operator">)
	*</span> list of registered functions<span class="operator"> (</span><span class="int">0</span><span class="operator">)

[</span>QxOrm<span class="operator">]</span> end dump all registered classes</pre>
           </td></tr></tbody></table>
           <br>
           <b>Note :</b> you can add some informations to introspection engine using <i>property bag</i> mechanism.
           Indeed, <i>qx::IxClass</i>, <i>qx::IxDataMember</i> and <i>qx::IxFunction</i> classes contain a list of <i>QVariant</i> items associated to a <i>QString</i> key (see <i>qx::QxPropertyBag</i> class for more details).<br>
           <br>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      <a name="faq_200"><u><b>How to register automatically Qt meta-properties (using <i>Q_PROPERTY</i> macro) to QxOrm context ?</b></u></a><br><br>
      <table border="0" style="width: 100%" align="center">
       <col>
       <col>
       <tbody>
         <tr>
           <td valign="middle" width="30"></td>
           <td align="justify">
           All classes inherited from <i>QObject</i> type can use <i><a href="http://doc.qt.nokia.com/latest/properties.html" target="_blank">Q_PROPERTY</a></i> macro : those properties become meta-properties.
           This is how Qt framework provides an introspection engine using the <i>moc</i> process.
           Meta-properties can be used for example by <i>QML</i> engine, <i>QtScript</i>, etc.<br>
           <br>
           <b>QxOrm</b> library needs to register each properties per class in the mapping function <i>void qx::register_class&lt;T&gt;()</i> to provide all features (persistence, XML and binary serialization, etc.).
           It's possible to register automatically all Qt meta-properties into QxOrm context without to manage any mapping function per class <i>void qx::register_class&lt;T&gt;()</i> : <b>QX_REGISTER_ALL_QT_PROPERTIES()</b> macro works with Qt introspection engine to iterate over all meta-properties.<br>
           <br>
           Here is an example with <i>TestQtProperty</i> class into <i>./test/qxDllSample/dll1/include/</i> directory of QxOrm package :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="TestQtProperty.h">
<pre><span class="pre">#ifndef _QX_TEST_QT_META_PROPERTY_H_
#define _QX_TEST_QT_META_PROPERTY_H_
</span><span class="keyword"> 
class</span> QX_DLL1_EXPORT TestQtProperty<span class="operator"> :</span><span class="keyword"> public</span> QObject<span class="operator">
{</span>

   Q_OBJECT
   Q_PROPERTY<span class="operator">(</span><span class="type">int</span> id READ id WRITE setId<span class="operator">)</span>
   Q_PROPERTY<span class="operator">(</span><span class="type">long</span> number READ number WRITE setNumber<span class="operator">)</span>
   Q_PROPERTY<span class="operator">(</span>QString desc READ desc WRITE setDesc<span class="operator">)</span>
   Q_PROPERTY<span class="operator">(</span>QDateTime birthDate READ birthDate WRITE setBirthDate<span class="operator">)</span>
   Q_PROPERTY<span class="operator">(</span>QVariant photo READ photo WRITE setPhoto<span class="operator">)</span><span class="keyword">

protected</span><span class="operator">:</span><span class="type">

   int</span>         m_id<span class="operator">;</span><span class="type">
   long</span>        m_number<span class="operator">;</span>
   QString     m_desc<span class="operator">;</span>
   QDateTime   m_birthDate<span class="operator">;</span>
   QVariant    m_photo<span class="operator">;</span><span class="keyword">

public</span><span class="operator">:</span>

   TestQtProperty<span class="operator">() :</span> QObject<span class="operator">(),</span> m_id<span class="operator">(</span><span class="int">0</span><span class="operator">),</span> m_number<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>TestQtProperty<span class="operator">() { ; }</span><span class="type">

   int</span> id<span class="operator">()</span><span class="keyword"> const</span><span class="operator">                {</span><span class="flow"> return</span> m_id<span class="operator">; }</span><span class="type">
   long</span> number<span class="operator">()</span><span class="keyword"> const</span><span class="operator">           {</span><span class="flow"> return</span> m_number<span class="operator">; }</span>
   QString desc<span class="operator">()</span><span class="keyword"> const</span><span class="operator">          {</span><span class="flow"> return</span> m_desc<span class="operator">; }</span>
   QDateTime birthDate<span class="operator">()</span><span class="keyword"> const</span><span class="operator">   {</span><span class="flow"> return</span> m_birthDate<span class="operator">; }</span>
   QVariant photo<span class="operator">()</span><span class="keyword"> const</span><span class="operator">        {</span><span class="flow"> return</span> m_photo<span class="operator">; }</span><span class="type">

   void</span> setId<span class="operator">(</span><span class="type">int</span> i<span class="operator">)                         {</span> m_id<span class="operator"> =</span> i<span class="operator">; }</span><span class="type">
   void</span> setNumber<span class="operator">(</span><span class="type">long</span> l<span class="operator">)                    {</span> m_number<span class="operator"> =</span> l<span class="operator">; }</span><span class="type">
   void</span> setDesc<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> s<span class="operator">)           {</span> m_desc<span class="operator"> =</span> s<span class="operator">; }</span><span class="type">
   void</span> setBirthDate<span class="operator">(</span><span class="keyword">const</span> QDateTime<span class="operator"> &amp;</span> dt<span class="operator">)   {</span> m_birthDate<span class="operator"> =</span> dt<span class="operator">; }</span><span class="type">
   void</span> setPhoto<span class="operator">(</span><span class="keyword">const</span> QVariant<span class="operator"> &amp;</span> v<span class="operator">)         {</span> m_photo<span class="operator"> =</span> v<span class="operator">; }
 
};</span>

QX_REGISTER_HPP_QX_DLL1<span class="operator">(</span>TestQtProperty<span class="operator">,</span> QObject<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="pre">

#endif // _QX_TEST_QT_META_PROPERTY_H_</span></pre>
           </td></tr></tbody></table>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="TestQtProperty.cpp">
<pre><span class="pre">#include "../include/precompiled.h"

#include "../include/TestQtProperty.h"

#include &lt;QxMemLeak.h&gt;
</span> 
QX_REGISTER_CPP_QX_DLL1<span class="operator">(</span>TestQtProperty<span class="operator">)</span>
QX_REGISTER_ALL_QT_PROPERTIES<span class="operator">(</span>TestQtProperty<span class="operator">,</span><span class="string"> "id"</span><span class="operator">)</span></pre>
           </td></tr></tbody></table>
           <br>
           If you don't want to use <i>QX_REGISTER_ALL_QT_PROPERTIES</i> macro, you can write 4 lines of code :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>TestQtProperty<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span> qx<span class="operator">::</span>register_all_qt_properties<span class="operator">&lt;</span>TestQtProperty<span class="operator">&gt;(</span>t<span class="operator">,</span><span class="string"> "id"</span><span class="operator">); }
}</span><span class="comment"> // namespace qx</span></pre>
           </td></tr></tbody></table>
           <br>
           <b>Note :</b> the second parameter of <i>QX_REGISTER_ALL_QT_PROPERTIES</i> macro is the name of the property mapped to the primary key into database.
           If this parameter is empty, then the class doesn't have any primary key or the primary key has been registered into a base class.<br>
           <br>
           All properties defined with <i>Q_PROPERTY</i> macro can be registered into QxOrm context in two different ways :<br>
           <b>1-</b> with the classic method : <i>t.data(& MyQObject::my_property, "my_property", 0);</i><br>
           <b>2-</b> or without writing the data-member pointer : <i>t.data("my_property", 0);</i><br>
           <br>
           You can use the first or the second method to register your properties into QxOrm context and access to the same functionalities using the common interface <i><a href="http://www.qxorm.com/doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a></i>.
           You can also mix Qt meta-properties and classic registration data-member into the same mapping function <i>void qx::register_class&lt;T&gt;()</i>.
           Each registration method has some advantages and disadvantages.<br>
           <br>
           Here is the list of advantages using the second registration method into QxOrm context :
           <ul>
             <li>much more faster to compile ;</li>
             <li>reduce exec size ;</li>
             <li>strong integration with Qt introspection/<i>moc</i> engine ;</li>
             <li>no need to manage any mapping function per class using <i>QX_REGISTER_ALL_QT_PROPERTIES</i> macro.</li>
           </ul>
           Here is the list of disadvantages compared to the classic registration method :
           <ul>
             <li>need to inherit from <i>QObject</i> class to use <i>Q_PROPERTY</i> macro ;</li>
             <li>program execution more slower (<i>QVariant</i> type versus C++ <i>template</i>) ;</li>
             <li>doesn't support relation between tables into database (<i>one-to-one</i>, <i>one-to-many</i>, <i>many-to-one</i> and <i>many-to-many</i>) ;</li>
             <li>cannot access to the data-member pointer of a class (need to convert to <i>QVariant</i> type before to access or to modify a value).</li>
           </ul>
           </td>
         </tr>
       </tbody>
      </table>
      <br><br>
      </td>
    </tr>
  </tbody>
</table>
<br><hr style="width: 80%" align="center" size="1" color="#100D5A">
<table border="0" style="width: 80%" align="center">
  <col><col>
  <tbody>
    <tr>
      <td align="left" valign="middle"><img alt="QxOrm"
        src="./resource/logo_qxorm_small.jpg" width="168" height="40"></td>
      <td align="right" valign="middle"><font size="2"></font> </td>
    </tr>
  </tbody>
</table>
</body>
</html>
